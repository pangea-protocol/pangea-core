{
  "address": "0xbC2C322ad20d16993E635d68cDAAEc4eA24d382c",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidFeeAndTickSpacing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnauthorisedDeployer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongTokenOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint24",
          "name": "",
          "type": "uint24"
        },
        {
          "internalType": "uint24",
          "name": "",
          "type": "uint24"
        }
      ],
      "name": "availableFeeAndTickSpacing",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "configAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_deployData",
          "type": "bytes"
        }
      ],
      "name": "deployPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "idx",
          "type": "uint256"
        }
      ],
      "name": "getPoolAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token0",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token1",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "name": "getPools",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "pairPools",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_masterDeployer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_poolLogger",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isPool",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "masterDeployer",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "poolLogger",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "pools",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token0",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token1",
          "type": "address"
        }
      ],
      "name": "poolsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint24",
          "name": "fee",
          "type": "uint24"
        },
        {
          "internalType": "uint24",
          "name": "tickSpacing",
          "type": "uint24"
        },
        {
          "internalType": "bool",
          "name": "ok",
          "type": "bool"
        }
      ],
      "name": "setAvailableFeeAndTickSpacing",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalPoolsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xbeea250eb4ec58d5cfc668ebbfdddd3f4d338de3ffb076cac20231baf285c180",
  "receipt": {
    "to": null,
    "from": "0x2A2F23ff33671361010D357529BDF0adca9416Fc",
    "contractAddress": "0xbC2C322ad20d16993E635d68cDAAEc4eA24d382c",
    "transactionIndex": 0,
    "gasUsed": "1720854",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x296e0c82bac9cf9cd4713c9aa49fe9ad01143e471ca582ccb1cc3f4a1c3449ae",
    "transactionHash": "0xbeea250eb4ec58d5cfc668ebbfdddd3f4d338de3ffb076cac20231baf285c180",
    "logs": [],
    "blockNumber": 98743461,
    "cumulativeGasUsed": "1720854",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7b141dad0ae9dd0a2ec46a2e595f9ebb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidFeeAndTickSpacing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorisedDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongTokenOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"availableFeeAndTickSpacing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"configAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_deployData\",\"type\":\"bytes\"}],\"name\":\"deployPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pairPools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolLogger\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLogger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"poolsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"tickSpacing\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"name\":\"setAvailableFeeAndTickSpacing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"configAddress\":{\"params\":{\"data\":\"abi.encode(address tokenA, address tokenB, uint24 swapFee, uint24 tickSpacing);\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"configAddress(bytes32)\":{\"notice\":\"Return the address of the pool created with the given config data\"},\"getPoolAddress(uint256)\":{\"notice\":\"Return the address of pool by index\"},\"getPools(address,address,uint256,uint256)\":{\"notice\":\"Return the list of pools composed of two tokens\"},\"isPool(address)\":{\"notice\":\"Return whether the pool is created by the factory\"},\"poolsCount(address,address)\":{\"notice\":\"Return the number of pools composed of two tokens\"},\"totalPoolsCount()\":{\"notice\":\"Return the number of pools deployed from factory\"}},\"notice\":\"Contract for deploying Concentrated Liquidity Pool\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/pool/ConcentratedLiquidityPoolFactory.sol\":\"ConcentratedLiquidityPoolFactory\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":99999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x652fee292f698d8dba81bf287cb71f1682f6483b67ebe601a5f7387dcfc30b34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"contracts/interfaces/IConcentratedLiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IMasterDeployer.sol\\\";\\nimport \\\"../libraries/Ticks.sol\\\";\\n\\n/// @notice concentrated liquidity pool contract Structs.\\ninterface IConcentratedLiquidityPoolStruct {\\n    struct Tick {\\n        /// @dev The highest tick below the current tick, pointer to the previous node in the linked list.\\n        int24 previousTick;\\n        /// @dev the lowest tick above the current tick, pointer to the next node in the linked list.\\n        int24 nextTick;\\n        /// @dev how much liquidity changes when the pool price crosses the tick\\n        uint128 liquidity;\\n        /// @dev the fee growth on the other side of the tick from the current tick in token0\\n        uint256 feeGrowthOutside0;\\n        /// @dev the fee growth on the other side of the tick from the current tick in token1\\n        uint256 feeGrowthOutside1;\\n        /// @dev the seconds spent per liquidity on the other side of the tick from the current tick\\n        uint160 secondsGrowthOutside;\\n    }\\n    struct Position {\\n        /// @dev the amount of liquidity in the position\\n        uint128 liquidity;\\n        /// @dev fee growth of token0 inside the tick range as of the last mint/burn/collect\\n        uint256 feeGrowthInside0Last;\\n        /// @dev fee growth of token1 inside the tick range as of the last mint/burn/collect\\n        uint256 feeGrowthInside1Last;\\n        /// @dev computed amount of token0 owed to the position as of the last mint/burn/collect\\n        uint128 feeOwed0;\\n        /// @dev computed amount of token1 owed to the position as of the last mint/burn/collect\\n        uint128 feeOwed1;\\n    }\\n\\n    struct MintParams {\\n        /// @dev lowerOld previous lower tick\\n        int24 lowerOld;\\n        /// @dev lower The lower end of the tick range for the position\\n        int24 lower;\\n        /// @dev upperOld previous upper tick\\n        int24 upperOld;\\n        /// @dev upper The upper end of the tick range for the position\\n        int24 upper;\\n        /// @dev amount0Desired The amount of token0 to mint the given amount of liquidity\\n        uint128 amount0Desired;\\n        /// @dev amount1Desired The amount of token1 to mint the given amount of liquidity\\n        uint128 amount1Desired;\\n    }\\n\\n    struct SwapCache {\\n        uint256 feeAmount;\\n        uint256 totalFeeAmount;\\n        uint256 protocolFee;\\n        uint256 swapFeeGrowthGlobalA;\\n        uint256 swapFeeGrowthGlobalB;\\n        uint256 currentPrice;\\n        uint256 currentLiquidity;\\n        uint256 input;\\n        int24 nextTickToCross;\\n    }\\n}\\n\\n/// @notice Concentrated Liquidity Pool interface.\\ninterface IConcentratedLiquidityPool is IConcentratedLiquidityPoolStruct {\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be created every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// @dev Reference: tickSpacing of 100 -> 1% between ticks.\\n    function tickSpacing() external view returns (uint24);\\n\\n    /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.\\n    function swapFee() external view returns (uint24);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    function token1() external view returns (address);\\n\\n    /// @notice list of the tokens of the pool, sorted by address\\n    function getAssets() external view returns (address[] memory tokens);\\n\\n    /// @notice Number of ticks on Pool, starts with two ticks (MIN_TICK & MAX_TICK)\\n    function totalTicks() external view returns (uint256);\\n\\n    /// @notice The currently in range liquidity available to the poo\\n    // @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Sqrt of price aka. \\u221a(token1/token0), multiplied by 2^96.\\n    function price() external view returns (uint160);\\n\\n    /// @notice Tick that is just below the current price.\\n    function nearestTick() external view returns (int24);\\n\\n    /// @notice price and nearestTick\\n    function getPriceAndNearestTicks() external view returns (uint160 price, int24 nearestTick);\\n\\n    /// @notice reserve of token0 and token1\\n    function getReserves() external view returns (uint128 reserve0, uint128 reserve1);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up, the log base 1.0001 of price of the pool\\n    function ticks(int24 tick) external view returns (Tick memory);\\n\\n    /// @notice Returns the information about a position\\n    /// @param owner owner of position, position is consisted of 3 elements, (owner / lower / upper)\\n    /// @param lower The lower tick of the position\\n    /// @param upper The upper tick of the position\\n    function positions(\\n        address owner,\\n        int24 lower,\\n        int24 upper\\n    ) external view returns (Position memory);\\n\\n    /// @notice The fee growth of token0 collected per unit of liquidity for the entire life of the pool\\n    function feeGrowthGlobal0() external view returns (uint256);\\n\\n    /// @notice The fee growth of token1 collected per unit of liquidity for the entire life of the pool\\n    function feeGrowthGlobal1() external view returns (uint256);\\n\\n    /// @notice The swap fee growth of token0 collected per unit of liquidity for the entire life of the pool\\n    function swapFeeGrowthGlobal0() external view returns (uint256);\\n\\n    /// @notice The swap fee growth of token1 collected per unit of liquidity for the entire life of the pool\\n    function swapFeeGrowthGlobal1() external view returns (uint256);\\n\\n    /// @notice fee growth of token0 & token1 inside the given price range\\n    /// @param lower The lower tick of the position\\n    /// @param upper The upper tick of the position\\n    function rangeFeeGrowth(int24 lower, int24 upper) external view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1);\\n\\n    /// @notice the address of factory contract\\n    function factory() external view returns (address);\\n\\n    /// @notice Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\\n    /// @param data abi.encode(bool zeroForOne, address recipient)\\n    function swap(bytes memory data) external returns (uint256 amountOut);\\n\\n    /// @notice Mints LP tokens - should be called via the Concentrated Liquidity pool manager contract.\\n    /// @param data MintParams(int24 lowerOld, int24 lower, int24 upperOld, int24 upper, uint128 amount0Desired, uint128 amount1Desired)\\n    function mint(MintParams memory data) external returns (uint256 liquidityMinted);\\n\\n    /// @notice Receive token0 or token1 and pay it back with fee\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Burns LP tokens - should be called via the Concentrated Liquidity pool manager contract.\\n    /// @param lower The lower tick of the position\\n    /// @param upper The upper tick of the position\\n    /// @param amount The amount of liquidity to burn\\n    function burn(\\n        int24 lower,\\n        int24 upper,\\n        uint128 amount\\n    ) external returns (uint256 token0Amount, uint256 token1Amount);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @param lower The lower tick of the position\\n    /// @param upper The upper tick of the position\\n    /// @param desiredToken0Fees How much token0 want be withdrawn from the fees owed\\n    /// @param desiredToken1Fees How much token1 want be withdrawn from the fees owed\\n    // @dev If desired fees exceeds the possible amount, only the possible amount will be returned.\\n    function collect(\\n        int24 lower,\\n        int24 upper,\\n        uint256 desiredToken0Fees,\\n        uint256 desiredToken1Fees\\n    ) external returns (uint256 token0Fees, uint256 token1Fees);\\n\\n    /// @notice Returns the information about a seconds global growth and the timestamp of the observation\\n    /// @return secondGrowthGlobal the seconds per in range liquidity for the life of the pool as of the observation timestamp\\n    /// @return lastObservation The timestamp of the observation\\n    function getSecondsGrowthAndLastObservation() external view returns (uint160 secondGrowthGlobal, uint32 lastObservation);\\n\\n    function collectProtocolFee() external returns (uint128, uint128);\\n\\n    function getImmutables()\\n        external\\n        view\\n        returns (\\n            uint128 MAX_TICK_LIQUIDITY,\\n            uint24 tickSpacing,\\n            uint24 swapFee,\\n            address factory,\\n            address masterDeployer,\\n            address token0,\\n            address token1\\n        );\\n}\\n\",\"keccak256\":\"0xb03df0ceac3b4385700afae66b72c99030843399c5efd1dfd2615d233f9facda\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IConcentratedLiquidityPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IPoolFactory.sol\\\";\\n\\n/// @notice Pool deployment interface.\\ninterface IConcentratedLiquidityPoolFactory is IPoolFactory {\\n    /// @notice create and deploy a pool. if exists, revert.\\n    /// @param deployData abi.encode(address tokenA, address tokenB, uint24 swapFee, uint160 price, uint24 tickSpacing)\\n    function deployPool(bytes calldata deployData) external returns (address pool);\\n\\n    /// @notice Return the address of the pool created with the given config data\\n    /// @param data abi.encode(address tokenA, address tokenB, uint24 swapFee, uint24 tickSpacing);\\n    function configAddress(bytes32 data) external returns (address pool);\\n\\n    /// @notice Return whether the pool is created by the factory\\n    function isPool(address pool) external returns (bool ok);\\n\\n    /// @notice Return the number of pools deployed from factory\\n    function totalPoolsCount() external view returns (uint256 total);\\n\\n    /// @notice Return the address of pool by index\\n    function getPoolAddress(uint256 idx) external view returns (address pool);\\n\\n    /// @notice Return the number of pools composed of two tokens\\n    function poolsCount(address token0, address token1) external view returns (uint256 count);\\n\\n    /// @notice Return the list of pools composed of two tokens\\n    function getPools(\\n        address token0,\\n        address token1,\\n        uint256 startIndex,\\n        uint256 count\\n    ) external view returns (address[] memory pairPools);\\n}\\n\",\"keccak256\":\"0x422e7a9d40f2ff07336a72850aba4801bf2ddcde45604ed10b9a363382a4a218\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IMasterDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice pool deployer interface.\\ninterface IMasterDeployer {\\n    // ============ EVENTS ================\\n    event DeployPool(address indexed factory, address indexed pool, bytes deployData);\\n    event AddToWhitelistFactory(address indexed factory);\\n    event RemoveFromWhitelistFactory(address indexed factory);\\n    event ProtocolFeeToUpdated(address protocolFeeTo);\\n\\n    /// @notice create pool through factory\\n    function deployPool(address factory, bytes calldata deployData) external returns (address);\\n\\n    /// @notice Return the address receiving protocol fees from Pool\\n    function protocolFeeTo() external view returns (address);\\n\\n    /// @notice Return whether the pool was deployed via a deployer\\n    function pools(address pool) external view returns (bool);\\n\\n    /// @notice LP Airdrop Distributor address\\n    function airdropDistributor() external returns (address);\\n\\n    /// @notice Return the number of pools deployed from masterDeployer\\n    function totalPoolsCount() external view returns (uint256 total);\\n\\n    /// @notice Return the address of pool by index\\n    function getPoolAddress(uint256 idx) external view returns (address pool);\\n\\n    /// @notice Return the address of Factory deployed pool\\n    function getFactoryAddress(address pool) external view returns (address factory);\\n}\\n\",\"keccak256\":\"0x78e000c156708cab98e97c281e357b4e5e000174f1b914ea5acdcd11181e4203\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPoolEventStruct.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\ninterface IPoolEventStruct {\\n    struct CreateLoggingParams {\\n        address token0;\\n        address token1;\\n        uint24 swapFee;\\n        uint160 price;\\n        uint24 tickSpacing;\\n    }\\n\\n    struct LiquidityLoggingParams {\\n        int24 lower;\\n        int24 upper;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 liquidity;\\n    }\\n\\n    struct CollectLoggingParams {\\n        uint256 amount0;\\n        uint256 amount1;\\n    }\\n\\n    struct SwapLoggingParams {\\n        bool zeroForOne;\\n        uint256 amountIn;\\n        uint256 amountOut;\\n    }\\n\\n    struct FlashLoggingParams {\\n        address sender;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 paid0;\\n        uint256 paid1;\\n    }\\n}\\n\",\"keccak256\":\"0xcc0f1d24f6f48573d0433421da7615b5b6d8cc53b40d9618457b39355460c9ca\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice Pool deployment interface.\\ninterface IPoolFactory {\\n    function deployPool(bytes calldata _deployData) external returns (address pool);\\n\\n    function configAddress(bytes32 data) external returns (address pool);\\n\\n    function isPool(address pool) external returns (bool ok);\\n}\\n\",\"keccak256\":\"0x2a289fce9555b2513f9dbf0b8d7f340db60693a8a50b257f7737ab7beb4c5b92\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPoolFactoryCallee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice pool interface called by factory contract\\ninterface IPoolFactoryCallee {\\n    function setPrice(uint160 price) external;\\n\\n    function registerLogger(address logger) external;\\n}\\n\",\"keccak256\":\"0x18ba424029770d0d9c1dd8750dd4895f71998f54b0c6dfed7bd565cfe2745951\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPoolFlashCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\ninterface IPoolFlashCallback {\\n    /// @notice Called to msg.sender after transferring to the recipient from Pool#flash\\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\\n    /// @param data Any data passed through by the caller via the Pool#flash call\\n    function flashCallback(\\n        uint256 fee0,\\n        uint256 fee1,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xd9df45958cc79c06e063ed322f99d417c77ccab27bf5374acc6331d26dc4aa1d\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPoolLogger.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IPoolEventStruct.sol\\\";\\n\\ninterface IPoolLogger is IPoolEventStruct {\\n    event Mint(address indexed pool, int24 lower, int24 upper, uint256 amount0, uint256 amount1, uint256 liquidity);\\n    event Burn(address indexed pool, int24 lower, int24 upper, uint256 amount0, uint256 amount1, uint256 liquidity);\\n    event Collect(address indexed pool, uint256 amount0, uint256 amount1);\\n    event Swap(address indexed pool, bool zeroForOne, uint256 amountIn, uint256 amountOut);\\n    event Flash(address indexed pool, address indexed sender, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\\n\\n    function emitMint(LiquidityLoggingParams memory params) external;\\n\\n    function emitBurn(LiquidityLoggingParams memory params) external;\\n\\n    function emitCollect(CollectLoggingParams memory params) external;\\n\\n    function emitSwap(SwapLoggingParams memory params) external;\\n\\n    function emitFlash(FlashLoggingParams memory params) external;\\n}\\n\",\"keccak256\":\"0x377f76ac6e2917652d6171e47135d51c05d65238c50ee3ac55aab7e5e5b042d0\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IPositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice concentrated Liquidity pool mint callback receiver.\\ninterface IPositionManager {\\n    function mintCallback(\\n        address token0,\\n        address token1,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6e00efc1ffbe98f0b8bade4d67b9968b4dd455c64854aa8322010a2319aef1e3\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IProtocolFeeReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\ninterface IProtocolFeeReceiver {\\n    function collectFeeCallback(address[] memory tokens, uint256[] memory amounts) external;\\n}\\n\",\"keccak256\":\"0x298999b7ecb42327ad6a805f749e84dbf2f5ab76f332eec95448fc325179dbbb\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/LPAirdropCallee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\ninterface LPAirdropCallee {\\n    function depositAirdrop(\\n        uint128 airdrop0,\\n        uint128 airdrop1,\\n        uint256 startTime,\\n        uint256 period\\n    ) external;\\n}\\n\",\"keccak256\":\"0x58743f91d0849a1f25f24c9eb87513d3f9c518f2ddffa6a74191f5e3199311f4\",\"license\":\"GPL-3.0\"},\"contracts/libraries/DyDxMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./FullMath.sol\\\";\\nimport \\\"./FixedPoint.sol\\\";\\nimport \\\"./UnsafeMath.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\n\\n/// @notice Math library that facilitates ranged liquidity calculations.\\nlibrary DyDxMath {\\n    function getDy(\\n        uint256 liquidity,\\n        uint256 priceLower,\\n        uint256 priceUpper,\\n        bool roundUp\\n    ) internal pure returns (uint256 dy) {\\n        unchecked {\\n            if (roundUp) {\\n                dy = FullMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, FixedPoint.Q96);\\n            } else {\\n                dy = FullMath.mulDiv(liquidity, priceUpper - priceLower, FixedPoint.Q96);\\n            }\\n        }\\n    }\\n\\n    function getDx(\\n        uint256 liquidity,\\n        uint256 priceLower,\\n        uint256 priceUpper,\\n        bool roundUp\\n    ) internal pure returns (uint256 dx) {\\n        unchecked {\\n            if (roundUp) {\\n                dx = UnsafeMath.divRoundingUp(\\n                    FullMath.mulDivRoundingUp(liquidity << FixedPoint.Q96RES, priceUpper - priceLower, priceUpper),\\n                    priceLower\\n                );\\n            } else {\\n                dx = FullMath.mulDiv(liquidity << FixedPoint.Q96RES, priceUpper - priceLower, priceUpper) / priceLower;\\n            }\\n        }\\n    }\\n\\n    function getLiquidityForAmounts(\\n        uint256 priceLower,\\n        uint256 priceUpper,\\n        uint256 currentPrice,\\n        uint256 dy,\\n        uint256 dx\\n    ) internal pure returns (uint256 liquidity) {\\n        unchecked {\\n            if (priceUpper <= currentPrice) {\\n                liquidity = FullMath.mulDiv(dy, FixedPoint.Q96, priceUpper - priceLower);\\n            } else if (currentPrice <= priceLower) {\\n                liquidity = FullMath.mulDiv(dx, FullMath.mulDiv(priceLower, priceUpper, FixedPoint.Q96), priceUpper - priceLower);\\n            } else {\\n                uint256 liquidity0 = FullMath.mulDiv(\\n                    dx,\\n                    FullMath.mulDiv(priceUpper, currentPrice, FixedPoint.Q96),\\n                    priceUpper - currentPrice\\n                );\\n                uint256 liquidity1 = FullMath.mulDiv(dy, FixedPoint.Q96, currentPrice - priceLower);\\n                liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n            }\\n        }\\n    }\\n\\n    function getAmountsForLiquidity(\\n        uint256 priceLower,\\n        uint256 priceUpper,\\n        uint256 currentPrice,\\n        uint256 liquidityAmount,\\n        bool roundUp\\n    ) internal pure returns (uint128 token0amount, uint128 token1amount) {\\n        if (priceUpper <= currentPrice) {\\n            // Only supply `token1` (`token1` is Y).\\n            token1amount = SafeCast.toUint128(DyDxMath.getDy(liquidityAmount, priceLower, priceUpper, roundUp));\\n        } else if (currentPrice <= priceLower) {\\n            // Only supply `token0` (`token0` is X).\\n            token0amount = SafeCast.toUint128(DyDxMath.getDx(liquidityAmount, priceLower, priceUpper, roundUp));\\n        } else {\\n            // Supply both tokens.\\n            token0amount = SafeCast.toUint128(DyDxMath.getDx(liquidityAmount, currentPrice, priceUpper, roundUp));\\n            token1amount = SafeCast.toUint128(DyDxMath.getDy(liquidityAmount, priceLower, currentPrice, roundUp));\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfd7e93680c237fbda55c989b3bbf3dcd14c4df5d40a0a9a997325d8a539f80cc\",\"license\":\"GPL-3.0\"},\"contracts/libraries/FeeLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./FullMath.sol\\\";\\nimport \\\"./FixedPoint.sol\\\";\\n\\n/// @notice Math library that facilitates fee handling for Concentrated Liquidity Pools.\\nlibrary FeeLib {\\n    function handleSwapFee(\\n        uint256 output,\\n        uint24 swapFee,\\n        uint256 protocolFeeRate,\\n        uint256 currentLiquidity,\\n        uint256 totalSwapFeeAmount,\\n        uint256 amountOut,\\n        uint256 protocolFee,\\n        uint256 feeGrowthGlobal\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 swapFeeAmount = FullMath.mulDivRoundingUp(output, swapFee, 1e6);\\n\\n        totalSwapFeeAmount += swapFeeAmount;\\n\\n        amountOut += output - swapFeeAmount;\\n\\n        // Calculate `protocolFeeRate` and convert pips to bips.\\n        uint256 feeDelta = FullMath.mulDivRoundingUp(swapFeeAmount, protocolFeeRate, 1e4);\\n\\n        protocolFee += feeDelta;\\n\\n        // Updating `feeAmount` based on the protocolFee.\\n        swapFeeAmount -= feeDelta;\\n\\n        feeGrowthGlobal += FullMath.mulDiv(swapFeeAmount, FixedPoint.Q128, currentLiquidity);\\n\\n        return (totalSwapFeeAmount, amountOut, protocolFee, feeGrowthGlobal);\\n    }\\n\\n    function calculateFlashFee(\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint24 feeRate\\n    ) internal pure returns (uint256 flashFee0, uint256 flashFee1) {\\n        flashFee0 = FullMath.mulDivRoundingUp(amount0, feeRate, 1e6);\\n        flashFee1 = FullMath.mulDivRoundingUp(amount1, feeRate, 1e6);\\n    }\\n}\\n\",\"keccak256\":\"0xc03b2f11689a6c01673d3cfb699b2bce2646251380cac28134d095d309094ec2\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nlibrary FixedPoint {\\n    uint8 internal constant Q128RES = 128;\\n    uint8 internal constant Q96RES = 96;\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x591a424ebe1e10342bf873b49a85989bcbca4b575846ed3d3f3a194f122fdbbd\",\"license\":\"GPL-3.0\"},\"contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.\\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol.\\n/// @dev Handles \\\"phantom overflow\\\", i.e., allows multiplication and division where an intermediate value overflows 256 bits.\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision - throws if result overflows an uint256 or denominator == 0.\\n    /// @param a The multiplicand.\\n    /// @param b The multiplier.\\n    /// @param denominator The divisor.\\n    /// @return result The 256-bit result.\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b.\\n            // Compute the product mod 2**256 and mod 2**256 - 1,\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product.\\n            uint256 prod1; // Most significant 256 bits of the product.\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n            // Make sure the result is less than 2**256 -\\n            // also prevents denominator == 0.\\n            require(denominator > prod1);\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n            // Make division exact by subtracting the remainder from [prod1 prod0] -\\n            // compute remainder using mulmod.\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number.\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n            // Factor powers of two out of denominator -\\n            // compute largest power of two divisor of denominator\\n            // (always >= 1).\\n            uint256 twos = uint256(-int256(denominator)) & denominator;\\n            // Divide denominator by power of two.\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n            // Divide [prod1 prod0] by the factors of two.\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos -\\n            // if twos is zero, then it becomes one.\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n            // Invert denominator mod 2**256 -\\n            // now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // for four bits. That is, denominator * inv = 1 mod 2**4.\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**8.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**16.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**32.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**64.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**128.\\n            inv *= 2 - denominator * inv; // Inverse mod 2**256.\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision - throws if result overflows an uint256 or denominator == 0.\\n    /// @param a The multiplicand.\\n    /// @param b The multiplier.\\n    /// @param denominator The divisor.\\n    /// @return result The 256-bit result.\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) != 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8211b004be6ff6be30b81fe484544d00c7bb467a4fd2a0d6c60114353e2300cf\",\"license\":\"MIT\"},\"contracts/libraries/SafeCast.sol\":{\"content\":\"//SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\nlibrary SafeCast {\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n\\n    function toInt128(uint256 y) internal pure returns (int128 z) {\\n        require(y <= 2**127 - 1);\\n        return int128(int256(y));\\n    }\\n}\\n\",\"keccak256\":\"0x26f130f9e37749f36d7c61bb818227d0ef4e089695be0009e9b626e63c7753c3\",\"license\":\"GPL-3.0\"},\"contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice Math library for computing sqrt price for ticks of size 1.0001, i.e., sqrt(1.0001^tick) as fixed point Q64.96 numbers - supports\\n/// prices between 2**-128 and 2**128 - 1.\\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol.\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128.\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128 - 1.\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MIN_TICK).\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MAX_TICK).\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    error TickOutOfBounds();\\n    error PriceOutOfBounds();\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96.\\n    /// @dev Throws if |tick| > max tick.\\n    /// @param tick The input tick for the above formula.\\n    /// @return sqrtPriceX96 Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick.\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        if (absTick > uint256(uint24(MAX_TICK))) revert TickOutOfBounds();\\n        unchecked {\\n            uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n            // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.\\n            // We round up in the division so getTickAtSqrtRatio of the output price is always consistent.\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    function validatePrice(uint160 price) internal pure {\\n        if (price < MIN_SQRT_RATIO || price >= MAX_SQRT_RATIO) revert PriceOutOfBounds();\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96.\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // Second inequality must be < because the price can never reach the price at the max tick.\\n        if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert PriceOutOfBounds();\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n        unchecked {\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number.\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2d20064b2a93ccddca358064e4843ebbe8c76fb75c85ce9c95d4050ee10d4ce5\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/Ticks.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./TickMath.sol\\\";\\nimport \\\"../interfaces/IConcentratedLiquidityPool.sol\\\";\\n\\n/// @notice Tick management library for ranged liquidity.\\nlibrary Ticks {\\n    function getMaxLiquidity(uint24 _tickSpacing) internal pure returns (uint128) {\\n        return type(uint128).max / uint128(uint24(TickMath.MAX_TICK) / (2 * uint24(_tickSpacing)));\\n    }\\n\\n    function cross(\\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\\n        int24 nextTickToCross,\\n        uint160 secondsGrowthGlobal,\\n        uint256 currentLiquidity,\\n        uint256 feeGrowthGlobalA,\\n        uint256 feeGrowthGlobalB,\\n        bool zeroForOne,\\n        uint24 tickSpacing\\n    ) internal returns (uint256, int24) {\\n        ticks[nextTickToCross].secondsGrowthOutside = secondsGrowthGlobal - ticks[nextTickToCross].secondsGrowthOutside;\\n\\n        if (zeroForOne) {\\n            // Moving backwards through the linked list.\\n            // Liquidity cannot overflow due to the MAX_TICK_LIQUIDITY requirement.\\n            unchecked {\\n                if ((nextTickToCross / int24(tickSpacing)) % 2 == 0) {\\n                    currentLiquidity -= ticks[nextTickToCross].liquidity;\\n                } else {\\n                    currentLiquidity += ticks[nextTickToCross].liquidity;\\n                }\\n            }\\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobalB - ticks[nextTickToCross].feeGrowthOutside0;\\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobalA - ticks[nextTickToCross].feeGrowthOutside1;\\n            nextTickToCross = ticks[nextTickToCross].previousTick;\\n        } else {\\n            // Moving forwards through the linked list.\\n            unchecked {\\n                if ((nextTickToCross / int24(tickSpacing)) % 2 == 0) {\\n                    currentLiquidity += ticks[nextTickToCross].liquidity;\\n                } else {\\n                    currentLiquidity -= ticks[nextTickToCross].liquidity;\\n                }\\n            }\\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobalB - ticks[nextTickToCross].feeGrowthOutside1;\\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobalA - ticks[nextTickToCross].feeGrowthOutside0;\\n            nextTickToCross = ticks[nextTickToCross].nextTick;\\n        }\\n        return (currentLiquidity, nextTickToCross);\\n    }\\n\\n    function insert(\\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\\n        uint256 feeGrowthGlobal0,\\n        uint256 feeGrowthGlobal1,\\n        uint160 secondsGrowthGlobal,\\n        int24 lowerOld,\\n        int24 lower,\\n        int24 upperOld,\\n        int24 upper,\\n        uint128 amount,\\n        int24 nearestTick,\\n        uint160 currentPrice\\n    ) public returns (int24, uint256 numOfInserted) {\\n        require(lower < upper, \\\"WRONG_ORDER\\\");\\n        require(TickMath.MIN_TICK <= lower, \\\"LOWER_RANGE\\\");\\n        require(upper <= TickMath.MAX_TICK, \\\"UPPER_RANGE\\\");\\n\\n        {\\n            // Stack overflow.\\n            uint128 currentLowerLiquidity = ticks[lower].liquidity;\\n            if (currentLowerLiquidity != 0 || lower == TickMath.MIN_TICK) {\\n                // We are adding liquidity to an existing tick.\\n                ticks[lower].liquidity = currentLowerLiquidity + amount;\\n            } else {\\n                // We are inserting a new tick.\\n                int24 oldNextTick;\\n                {\\n                    IConcentratedLiquidityPoolStruct.Tick storage old = ticks[lowerOld];\\n                    oldNextTick = old.nextTick;\\n                    old.nextTick = lower;\\n                    require(\\n                        (old.liquidity != 0 || lowerOld == TickMath.MIN_TICK) && lowerOld < lower && lower < oldNextTick,\\n                        \\\"LOWER_ORDER\\\"\\n                    );\\n                }\\n\\n                if (lower <= TickMath.getTickAtSqrtRatio(currentPrice)) {\\n                    ticks[lower] = IConcentratedLiquidityPoolStruct.Tick(\\n                        lowerOld,\\n                        oldNextTick,\\n                        amount,\\n                        feeGrowthGlobal0,\\n                        feeGrowthGlobal1,\\n                        secondsGrowthGlobal\\n                    );\\n                } else {\\n                    ticks[lower] = IConcentratedLiquidityPoolStruct.Tick(lowerOld, oldNextTick, amount, 0, 0, 0);\\n                }\\n\\n                ticks[oldNextTick].previousTick = lower;\\n                numOfInserted += 1;\\n            }\\n        }\\n\\n        uint128 currentUpperLiquidity = ticks[upper].liquidity;\\n        if (currentUpperLiquidity != 0 || upper == TickMath.MAX_TICK) {\\n            // We are adding liquidity to an existing tick.\\n            ticks[upper].liquidity = currentUpperLiquidity + amount;\\n        } else {\\n            // Inserting a new tick.\\n            int24 oldNextTick;\\n            {\\n                IConcentratedLiquidityPoolStruct.Tick storage old = ticks[upperOld];\\n                oldNextTick = old.nextTick;\\n                old.nextTick = upper;\\n                require(old.liquidity != 0 && oldNextTick > upper && upperOld < upper, \\\"UPPER_ORDER\\\");\\n            }\\n\\n            if (upper <= TickMath.getTickAtSqrtRatio(currentPrice)) {\\n                ticks[upper] = IConcentratedLiquidityPoolStruct.Tick(\\n                    upperOld,\\n                    oldNextTick,\\n                    amount,\\n                    feeGrowthGlobal0,\\n                    feeGrowthGlobal1,\\n                    secondsGrowthGlobal\\n                );\\n            } else {\\n                ticks[upper] = IConcentratedLiquidityPoolStruct.Tick(upperOld, oldNextTick, amount, 0, 0, 0);\\n            }\\n\\n            ticks[oldNextTick].previousTick = upper;\\n            numOfInserted += 1;\\n        }\\n\\n        int24 tickAtPrice = TickMath.getTickAtSqrtRatio(currentPrice);\\n\\n        if (nearestTick < upper && upper <= tickAtPrice) {\\n            nearestTick = upper;\\n        } else if (nearestTick < lower && lower <= tickAtPrice) {\\n            nearestTick = lower;\\n        }\\n\\n        return (nearestTick, numOfInserted);\\n    }\\n\\n    function remove(\\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\\n        int24 lower,\\n        int24 upper,\\n        uint128 amount,\\n        int24 nearestTick\\n    ) public returns (int24, uint256 numOfRemoved) {\\n        IConcentratedLiquidityPoolStruct.Tick storage current = ticks[lower];\\n\\n        if (lower != TickMath.MIN_TICK && current.liquidity == amount) {\\n            // Delete lower tick.\\n            IConcentratedLiquidityPoolStruct.Tick storage previous = ticks[current.previousTick];\\n            IConcentratedLiquidityPoolStruct.Tick storage next = ticks[current.nextTick];\\n\\n            previous.nextTick = current.nextTick;\\n            next.previousTick = current.previousTick;\\n\\n            if (nearestTick == lower) nearestTick = current.previousTick;\\n\\n            delete ticks[lower];\\n            numOfRemoved += 1;\\n        } else {\\n            unchecked {\\n                current.liquidity -= amount;\\n            }\\n        }\\n\\n        current = ticks[upper];\\n\\n        if (upper != TickMath.MAX_TICK && current.liquidity == amount) {\\n            // Delete upper tick.\\n            IConcentratedLiquidityPoolStruct.Tick storage previous = ticks[current.previousTick];\\n            IConcentratedLiquidityPoolStruct.Tick storage next = ticks[current.nextTick];\\n\\n            previous.nextTick = current.nextTick;\\n            next.previousTick = current.previousTick;\\n\\n            if (nearestTick == upper) nearestTick = current.previousTick;\\n\\n            delete ticks[upper];\\n            numOfRemoved += 1;\\n        } else {\\n            unchecked {\\n                current.liquidity -= amount;\\n            }\\n        }\\n\\n        return (nearestTick, numOfRemoved);\\n    }\\n}\\n\",\"keccak256\":\"0x0669f4e0e9ae2e042e976f5fd5274fb6c9b2f12da55e4dc4bdcd762e4d45a9d5\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice Math library that contains methods that perform common math functions but do not do any overflow or underflow checks.\\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/UnsafeMath.sol.\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y).\\n    /// @dev Division by 0 has unspecified behavior, and must be checked externally.\\n    /// @param x The dividend.\\n    /// @param y The divisor.\\n    /// @return z The quotient, ceil(x / y).\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := add(div(x, y), gt(mod(x, y), 0))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xea315497f3b3f0dcf40535dd8a130e3615ffaaa18a735eb6ec48f990fac148a0\",\"license\":\"GPL-2.0-or-later\"},\"contracts/pool/ConcentratedLiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n *\\n * #####    ##   #    #  ####  ######   ##      #####  #####   ####  #####  ####   ####   ####  #\\n * #    #  #  #  ##   # #    # #       #  #     #    # #    # #    #   #   #    # #    # #    # #\\n * #    # #    # # #  # #      #####  #    #    #    # #    # #    #   #   #    # #      #    # #\\n * #####  ###### #  # # #  ### #      ######    #####  #####  #    #   #   #    # #      #    # #\\n * #      #    # #   ## #    # #      #    #    #      #   #  #    #   #   #    # #    # #    # #\\n * #      #    # #    #  ####  ###### #    #    #      #    #  ####    #    ####   ####   ####  ######\\n *\\n */\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../interfaces/IMasterDeployer.sol\\\";\\nimport \\\"../interfaces/IPositionManager.sol\\\";\\nimport \\\"../interfaces/IPoolEventStruct.sol\\\";\\nimport \\\"../interfaces/IPoolLogger.sol\\\";\\nimport \\\"../interfaces/IPoolFlashCallback.sol\\\";\\nimport \\\"../interfaces/IConcentratedLiquidityPool.sol\\\";\\nimport \\\"../interfaces/LPAirdropCallee.sol\\\";\\nimport \\\"../interfaces/IPoolFactoryCallee.sol\\\";\\nimport \\\"../interfaces/IProtocolFeeReceiver.sol\\\";\\nimport \\\"../libraries/FullMath.sol\\\";\\nimport \\\"../libraries/TickMath.sol\\\";\\nimport \\\"../libraries/UnsafeMath.sol\\\";\\nimport \\\"../libraries/DyDxMath.sol\\\";\\nimport \\\"../libraries/FeeLib.sol\\\";\\nimport \\\"../libraries/Ticks.sol\\\";\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\n/// @notice Concentrated liquidity pool implementation.\\n/// @dev Based on Trident source code - Concentrated Liquidity Pool\\ncontract ConcentratedLiquidityPool is IConcentratedLiquidityPoolStruct, IPoolFactoryCallee, LPAirdropCallee {\\n    using SafeERC20 for IERC20;\\n    using Ticks for mapping(int24 => Tick);\\n\\n    /// @dev `protocolFee` is 10% of the total swap fee\\n    uint256 public constant protocolFee = 1000;\\n\\n    /// @dev Reference: tickSpacing of 100 -> 1% between ticks.\\n    uint24 public immutable tickSpacing;\\n\\n    /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.\\n    uint24 public immutable swapFee;\\n    uint128 internal immutable MAX_TICK_LIQUIDITY;\\n\\n    IMasterDeployer internal immutable masterDeployer;\\n    IPoolLogger internal logger;\\n\\n    address public immutable token0;\\n    address public immutable token1;\\n    address public immutable factory;\\n\\n    uint128 public liquidity;\\n\\n    /// @dev Multiplied by 2^128.\\n    uint160 internal secondsGrowthGlobal;\\n    uint32 internal lastObservation;\\n\\n    /// @dev swap fee growth counters are multiplied by 2 ^ 128.\\n    /// total fee (reward) = swap fee + airdrop\\n    ///  * swap Fee = Tokens accrued from swaps in the pool\\n    ///  * airdrop = Tokens provided to directly reward Liquidity Providers\\n    uint256 public swapFeeGrowthGlobal0;\\n    uint256 public swapFeeGrowthGlobal1;\\n\\n    /// @dev airdrop fee growth counters are multiplied by 2 ^ 128.\\n    uint256 internal airdropGrowthGlobal0;\\n    uint256 internal airdropGrowthGlobal1;\\n\\n    /// @dev airdrop Fee distribution Rate per second at current epoch, multiplied by 2 ^ 128\\n    uint256 public airdrop0PerSecond;\\n    uint256 public airdrop1PerSecond;\\n\\n    uint256 public airdropStartTime;\\n    uint256 public airdropPeriod;\\n\\n    uint128 internal token0ProtocolFee;\\n    uint128 internal token1ProtocolFee;\\n\\n    uint128 internal reserve0;\\n    uint128 internal reserve1;\\n\\n    /// @dev Sqrt of price aka. \\u221a(token1/token0), multiplied by 2 ^ 96.\\n    uint160 public price;\\n    /// @dev Tick that is just below the current price.\\n    int24 public nearestTick;\\n\\n    uint256 internal unlocked;\\n\\n    uint256 public totalTicks;\\n    mapping(int24 => Tick) public ticks;\\n    mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;\\n\\n    uint256 public immutable createdTime;\\n    uint256 public immutable createdBlockNumber;\\n\\n    /// @dev Error list to optimize around pool requirements.\\n    error Locked();\\n    error ZeroAddress();\\n    error InvalidSwapFee();\\n    error LiquidityOverflow();\\n    error LiquidityZero();\\n    error LiquidityInsufficient();\\n    error Token0Missing();\\n    error Token1Missing();\\n    error InvalidTick();\\n    error InvalidParam();\\n    error LowerEven();\\n    error UpperOdd();\\n    error Overflow();\\n    error NotAuthorized();\\n    error AlreadyPriceInitialized();\\n\\n    modifier lock() {\\n        if (unlocked == 2) revert Locked();\\n        unlocked = 2;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    /// @dev Only set immutable variables here - state changes made here will not be used.\\n    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {\\n        (address _token0, address _token1, uint24 _swapFee, uint24 _tickSpacing) = abi.decode(\\n            _deployData,\\n            (address, address, uint24, uint24)\\n        );\\n\\n        if (_token0 == address(0)) revert ZeroAddress();\\n        if (_token0 == _token1) revert InvalidParam();\\n\\n        token0 = _token0;\\n        token1 = _token1;\\n        swapFee = _swapFee;\\n        tickSpacing = _tickSpacing;\\n        factory = msg.sender;\\n        masterDeployer = _masterDeployer;\\n\\n        MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);\\n        ticks[TickMath.MIN_TICK] = Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\\n        ticks[TickMath.MAX_TICK] = Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\\n        nearestTick = TickMath.MIN_TICK;\\n        unlocked = 1;\\n        lastObservation = uint32(block.timestamp);\\n        totalTicks = 2;\\n\\n        createdTime = block.timestamp;\\n        createdBlockNumber = block.number;\\n    }\\n\\n    /// @dev Price is not a constructor parameter to allow for predictable address calculation.\\n    function setPrice(uint160 _price) external {\\n        if (msg.sender != factory) revert NotAuthorized();\\n        if (price != 0) revert AlreadyPriceInitialized();\\n        TickMath.validatePrice(_price);\\n        price = _price;\\n    }\\n\\n    /// @dev Called only once from the factory.\\n    function registerLogger(address _logger) external {\\n        if (msg.sender != factory) revert NotAuthorized();\\n        logger = IPoolLogger(_logger);\\n    }\\n\\n    /// @dev Mints LP tokens - should be called via the CL pool manager contract.\\n    function mint(MintParams memory mintParams) external lock returns (uint256 liquidityMinted) {\\n        _ensureTickSpacing(mintParams.lower, mintParams.upper);\\n\\n        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));\\n        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));\\n        uint256 currentPrice = uint256(price);\\n        liquidityMinted = DyDxMath.getLiquidityForAmounts(\\n            priceLower,\\n            priceUpper,\\n            currentPrice,\\n            uint256(mintParams.amount1Desired),\\n            uint256(mintParams.amount0Desired)\\n        );\\n\\n        // Ensure no overflow happens when we cast from uint256 to int128.\\n        if (liquidityMinted > uint128(type(int128).max)) revert Overflow();\\n        if (liquidityMinted == 0) revert LiquidityZero();\\n\\n        _updateObservationRecord(uint256(liquidity));\\n\\n        {\\n            uint256 numOfInserted;\\n            (nearestTick, numOfInserted) = Ticks.insert(\\n                ticks,\\n                swapFeeGrowthGlobal0 + airdropGrowthGlobal0,\\n                swapFeeGrowthGlobal1 + airdropGrowthGlobal1,\\n                secondsGrowthGlobal,\\n                mintParams.lowerOld,\\n                mintParams.lower,\\n                mintParams.upperOld,\\n                mintParams.upper,\\n                uint128(liquidityMinted),\\n                nearestTick,\\n                uint160(currentPrice)\\n            );\\n            totalTicks += numOfInserted;\\n        }\\n\\n        unchecked {\\n            // already all initialized\\n            _updatePosition(msg.sender, mintParams.lower, mintParams.upper, int128(uint128(liquidityMinted)));\\n            if (priceLower <= currentPrice && currentPrice < priceUpper) liquidity += uint128(liquidityMinted);\\n        }\\n\\n        (uint128 amount0Actual, uint128 amount1Actual) = DyDxMath.getAmountsForLiquidity(\\n            priceLower,\\n            priceUpper,\\n            currentPrice,\\n            liquidityMinted,\\n            true\\n        );\\n\\n        IPositionManager(msg.sender).mintCallback(token0, token1, amount0Actual, amount1Actual);\\n\\n        if (amount0Actual != 0) {\\n            reserve0 += amount0Actual;\\n            if (reserve0 > _balance(token0)) revert Token0Missing();\\n        }\\n\\n        if (amount1Actual != 0) {\\n            reserve1 += amount1Actual;\\n            if (reserve1 > _balance(token1)) revert Token1Missing();\\n        }\\n\\n        try\\n            logger.emitMint(\\n                IPoolEventStruct.LiquidityLoggingParams({\\n                    lower: mintParams.lower,\\n                    upper: mintParams.upper,\\n                    amount0: amount0Actual,\\n                    amount1: amount1Actual,\\n                    liquidity: liquidityMinted\\n                })\\n            )\\n        {} catch {}\\n    }\\n\\n    function burn(\\n        int24 lower,\\n        int24 upper,\\n        uint128 amount\\n    ) external lock returns (uint256 token0Amount, uint256 token1Amount) {\\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\\n        uint160 currentPrice = price;\\n\\n        _updateObservationRecord(uint256(liquidity));\\n\\n        unchecked {\\n            if (priceLower <= currentPrice && currentPrice < priceUpper) liquidity -= amount;\\n        }\\n\\n        (token0Amount, token1Amount) = DyDxMath.getAmountsForLiquidity(\\n            uint256(priceLower),\\n            uint256(priceUpper),\\n            uint256(currentPrice),\\n            uint256(amount),\\n            false\\n        );\\n\\n        // Ensure no overflow happens when we cast from uint128 to int128.\\n        if (amount > uint128(type(int128).max)) revert Overflow();\\n\\n        _updatePosition(msg.sender, lower, upper, -int128(amount));\\n\\n        unchecked {\\n            reserve0 -= uint128(token0Amount);\\n            reserve1 -= uint128(token1Amount);\\n        }\\n\\n        _transferBothTokens(msg.sender, token0Amount, token1Amount);\\n\\n        {\\n            uint256 numOfRemoved;\\n            (nearestTick, numOfRemoved) = Ticks.remove(ticks, lower, upper, amount, nearestTick);\\n            totalTicks -= numOfRemoved;\\n        }\\n\\n        try\\n            logger.emitBurn(\\n                IPoolEventStruct.LiquidityLoggingParams({\\n                    lower: lower,\\n                    upper: upper,\\n                    amount0: token0Amount,\\n                    amount1: token1Amount,\\n                    liquidity: uint256(amount)\\n                })\\n            )\\n        {} catch {}\\n    }\\n\\n    function collect(\\n        int24 lower,\\n        int24 upper,\\n        uint256 desiredToken0Fees,\\n        uint256 desiredToken1Fees\\n    ) external lock returns (uint256 token0Fees, uint256 token1Fees) {\\n        _updatePosition(msg.sender, lower, upper, 0);\\n        (token0Fees, token1Fees) = _collectFromFeeOwed(msg.sender, lower, upper, desiredToken0Fees, desiredToken1Fees);\\n\\n        reserve0 -= uint128(token0Fees);\\n        reserve1 -= uint128(token1Fees);\\n\\n        _transferBothTokens(msg.sender, token0Fees, token1Fees);\\n\\n        try logger.emitCollect(IPoolEventStruct.CollectLoggingParams({amount0: token0Fees, amount1: token1Fees})) {} catch {}\\n    }\\n\\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\\n    function swap(bytes memory data) external lock returns (uint256 amountOut) {\\n        (bool zeroForOne, address recipient) = abi.decode(data, (bool, address));\\n\\n        uint256 inAmount = _balance(zeroForOne ? token0 : token1) - (zeroForOne ? reserve0 : reserve1);\\n\\n        SwapCache memory cache = SwapCache({\\n            feeAmount: 0,\\n            totalFeeAmount: 0,\\n            protocolFee: 0,\\n            swapFeeGrowthGlobalA: zeroForOne ? swapFeeGrowthGlobal1 : swapFeeGrowthGlobal0,\\n            swapFeeGrowthGlobalB: zeroForOne ? swapFeeGrowthGlobal0 : swapFeeGrowthGlobal1,\\n            currentPrice: uint256(price),\\n            currentLiquidity: uint256(liquidity),\\n            input: inAmount,\\n            nextTickToCross: zeroForOne ? nearestTick : ticks[nearestTick].nextTick\\n        });\\n\\n        _ensureLiquidityForSwap(cache);\\n\\n        _updateObservationRecord(cache.currentLiquidity);\\n\\n        while (cache.input != 0) {\\n            uint256 nextTickPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\\n            uint256 output = 0;\\n            bool cross = false;\\n\\n            if (zeroForOne) {\\n                // Trading token 0 (x) for token 1 (y).\\n                // Price is decreasing.\\n                // Maximum input amount within current tick range: \\u0394x = \\u0394(1/\\u221a\\ud835\\udc43) \\u00b7 L.\\n                uint256 maxDx = DyDxMath.getDx(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\\n\\n                if (cache.input <= maxDx) {\\n                    // We can swap within the current range.\\n                    uint256 liquidityPadded = cache.currentLiquidity << FixedPoint.Q96RES;\\n                    // Calculate new price after swap: \\u221a\\ud835\\udc43[new] =  L \\u00b7 \\u221a\\ud835\\udc43 / (L + \\u0394x \\u00b7 \\u221a\\ud835\\udc43)\\n                    // This is derived from \\u0394(1/\\u221a\\ud835\\udc43) = \\u0394x/L\\n                    // where \\u0394(1/\\u221a\\ud835\\udc43) is 1/\\u221a\\ud835\\udc43[old] - 1/\\u221a\\ud835\\udc43[new] and we solve for \\u221a\\ud835\\udc43[new].\\n                    // In case of an overflow we can use: \\u221a\\ud835\\udc43[new] = L / (L / \\u221a\\ud835\\udc43 + \\u0394x).\\n                    // This is derived by dividing the original fraction by \\u221a\\ud835\\udc43 on both sides.\\n                    uint256 newPrice = uint256(\\n                        FullMath.mulDivRoundingUp(liquidityPadded, cache.currentPrice, liquidityPadded + cache.currentPrice * cache.input)\\n                    );\\n\\n                    if (!(nextTickPrice <= newPrice && newPrice < cache.currentPrice)) {\\n                        // Overflow. We use a modified version of the formula.\\n                        newPrice = uint160(UnsafeMath.divRoundingUp(liquidityPadded, liquidityPadded / cache.currentPrice + cache.input));\\n                    }\\n                    // Based on the price difference calculate the output of th swap: \\u0394y = \\u0394\\u221aP \\u00b7 L.\\n                    output = DyDxMath.getDy(cache.currentLiquidity, newPrice, cache.currentPrice, false);\\n                    cache.currentPrice = newPrice;\\n                    cache.input = 0;\\n                } else {\\n                    // Execute swap step and cross the tick.\\n                    output = DyDxMath.getDy(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\\n                    cache.currentPrice = nextTickPrice;\\n                    cross = true;\\n                    cache.input -= maxDx;\\n                }\\n            } else {\\n                // Price is increasing.\\n                // Maximum swap amount within the current tick range: \\u0394y = \\u0394\\u221aP \\u00b7 L.\\n                uint256 maxDy = DyDxMath.getDy(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\\n\\n                if (cache.input <= maxDy) {\\n                    // We can swap within the current range.\\n                    // Calculate new price after swap: \\u0394P = \\u0394y/L.\\n                    uint256 newPrice = cache.currentPrice + FullMath.mulDiv(cache.input, FixedPoint.Q96, cache.currentLiquidity);\\n                    // Calculate output of swap\\n                    // - \\u0394x = \\u0394(1/\\u221aP) \\u00b7 L.\\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, newPrice, false);\\n                    cache.currentPrice = newPrice;\\n                    cache.input = 0;\\n                } else {\\n                    // Swap & cross the tick.\\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\\n                    cache.currentPrice = nextTickPrice;\\n                    cross = true;\\n                    cache.input -= maxDy;\\n                }\\n            }\\n\\n            // cache.feeGrowthGlobalA is the feeGrowthGlobal counter for the output token.\\n            // It increases each swap step.\\n            if (cache.currentLiquidity > 0) {\\n                (cache.totalFeeAmount, amountOut, cache.protocolFee, cache.swapFeeGrowthGlobalA) = FeeLib.handleSwapFee(\\n                    output,\\n                    swapFee,\\n                    protocolFee,\\n                    cache.currentLiquidity,\\n                    cache.totalFeeAmount,\\n                    amountOut,\\n                    cache.protocolFee,\\n                    cache.swapFeeGrowthGlobalA\\n                );\\n            }\\n\\n            if (cross) {\\n                _cross(cache, zeroForOne);\\n\\n                if (cache.currentLiquidity == 0) {\\n                    if (cache.nextTickToCross == TickMath.MIN_TICK || cache.nextTickToCross == TickMath.MAX_TICK) {\\n                        // In the case of the last tick, there is no next tick.\\n                        // price must be crossed because of rangeFeeGrowth\\n                        if (zeroForOne) {\\n                            cache.currentPrice = Math.max(cache.currentPrice - 1, TickMath.MIN_SQRT_RATIO);\\n                            cache.nextTickToCross = ticks[cache.nextTickToCross].previousTick;\\n                        } else {\\n                            cache.currentPrice = Math.min(cache.currentPrice + 1, TickMath.MAX_SQRT_RATIO - 1);\\n                            cache.nextTickToCross = ticks[cache.nextTickToCross].nextTick;\\n                        }\\n                        break;\\n                    }\\n\\n                    // We step into a zone that has liquidity\\n                    cache.currentPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\\n                    _cross(cache, zeroForOne);\\n                }\\n            }\\n        }\\n\\n        price = uint160(cache.currentPrice);\\n\\n        int24 newNearestTick = zeroForOne ? cache.nextTickToCross : ticks[cache.nextTickToCross].previousTick;\\n\\n        if (nearestTick != newNearestTick) {\\n            nearestTick = newNearestTick;\\n            liquidity = uint128(cache.currentLiquidity);\\n        }\\n\\n        _updateReserves(zeroForOne, uint128(inAmount), amountOut);\\n\\n        _updateSwapFees(zeroForOne, cache.swapFeeGrowthGlobalA, uint128(cache.protocolFee));\\n\\n        if (zeroForOne) {\\n            _transfer(token1, amountOut, recipient);\\n        } else {\\n            _transfer(token0, amountOut, recipient);\\n        }\\n\\n        try\\n            logger.emitSwap(IPoolEventStruct.SwapLoggingParams({zeroForOne: zeroForOne, amountIn: inAmount, amountOut: amountOut}))\\n        {} catch {}\\n    }\\n\\n    function _cross(SwapCache memory cache, bool zeroForOne) internal {\\n        (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(\\n            ticks,\\n            cache.nextTickToCross,\\n            secondsGrowthGlobal,\\n            cache.currentLiquidity,\\n            zeroForOne ? cache.swapFeeGrowthGlobalA + airdropGrowthGlobal1 : cache.swapFeeGrowthGlobalA + airdropGrowthGlobal0,\\n            zeroForOne ? cache.swapFeeGrowthGlobalB + airdropGrowthGlobal0 : cache.swapFeeGrowthGlobalB + airdropGrowthGlobal1,\\n            zeroForOne,\\n            tickSpacing\\n        );\\n    }\\n\\n    /// @notice Receive token0 or token1 and pay it back with fee\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external lock {\\n        uint256 _liquidity = liquidity;\\n        if (_liquidity == 0) revert LiquidityZero();\\n\\n        uint256 balance0Before = reserve0;\\n        uint256 balance1Before = reserve1;\\n\\n        _transferBothTokens(recipient, amount0, amount1);\\n        (uint256 flashFee0, uint256 flashFee1) = FeeLib.calculateFlashFee(amount0, amount1, swapFee);\\n        IPoolFlashCallback(msg.sender).flashCallback(flashFee0, flashFee1, data);\\n\\n        uint256 paid0;\\n        uint256 paid1;\\n        {\\n            uint256 balance0After = _balance(token0);\\n            uint256 balance1After = _balance(token1);\\n\\n            if (balance0Before + flashFee0 > balance0After) revert Token0Missing();\\n            if (balance1Before + flashFee1 > balance1After) revert Token1Missing();\\n\\n            // update reserves info\\n            reserve0 = SafeCast.toUint128(balance0After);\\n            reserve1 = SafeCast.toUint128(balance1After);\\n\\n            paid0 = balance0After - balance0Before;\\n            paid1 = balance1After - balance1Before;\\n        }\\n\\n        uint256 _protocolFeeRate = protocolFee;\\n\\n        if (paid0 > 0) {\\n            // update swap Fee & protocol Fee for token0\\n            uint128 delta0 = uint128(FullMath.mulDivRoundingUp(paid0, _protocolFeeRate, 1e4));\\n            token0ProtocolFee += delta0;\\n            swapFeeGrowthGlobal0 += FullMath.mulDiv(paid0 - delta0, FixedPoint.Q128, _liquidity);\\n        }\\n\\n        if (paid1 > 0) {\\n            // update swap Fee & protocol Fee for token1\\n            uint128 delta1 = uint128(FullMath.mulDivRoundingUp(paid1, _protocolFeeRate, 1e4));\\n            token1ProtocolFee += delta1;\\n            swapFeeGrowthGlobal1 += FullMath.mulDiv(paid1 - delta1, FixedPoint.Q128, _liquidity);\\n        }\\n\\n        try\\n            logger.emitFlash(\\n                IPoolEventStruct.FlashLoggingParams({sender: msg.sender, amount0: amount0, amount1: amount1, paid0: paid0, paid1: paid1})\\n            )\\n        {} catch {}\\n    }\\n\\n    /// @dev Collects Protocol Fees\\n    function collectProtocolFee() external lock returns (uint128 amount0, uint128 amount1) {\\n        address _protocolFeeTo = masterDeployer.protocolFeeTo();\\n        address[] memory tokens = new address[](2);\\n        uint256[] memory amounts = new uint256[](2);\\n\\n        if (token0ProtocolFee > 0) {\\n            amount0 = token0ProtocolFee;\\n            token0ProtocolFee = 0;\\n            reserve0 -= amount0;\\n\\n            _transfer(token0, amount0, _protocolFeeTo);\\n            tokens[0] = token0;\\n            amounts[0] = amount0;\\n        }\\n\\n        if (token1ProtocolFee > 0) {\\n            amount1 = token1ProtocolFee;\\n            token1ProtocolFee = 0;\\n            reserve1 -= amount1;\\n\\n            _transfer(token1, amount1, _protocolFeeTo);\\n            tokens[1] = token1;\\n            amounts[1] = amount1;\\n        }\\n\\n        if (_protocolFeeTo.code.length > 0) {\\n            // if protocolFee is contract, call callback\\n            IProtocolFeeReceiver(_protocolFeeTo).collectFeeCallback(tokens, amounts);\\n        }\\n        return (amount0, amount1);\\n    }\\n\\n    /// @dev deposit Airdrop tokens. This Airdrop will be provided to the LP with the swap Fee for a given period\\n    /// @param airdrop0   amount of token0 to deposit\\n    /// @param airdrop1   amount of token1 to deposit\\n    /// @param startTime  Airdrop distribution start time\\n    /// @param period     Airdrop distribution period\\n    function depositAirdrop(\\n        uint128 airdrop0,\\n        uint128 airdrop1,\\n        uint256 startTime,\\n        uint256 period\\n    ) external lock {\\n        if (masterDeployer.airdropDistributor() != msg.sender) revert NotAuthorized();\\n        if (startTime + period <= block.timestamp) revert InvalidParam();\\n\\n        // not allowed before the previous airdrop is ended\\n        uint256 _airdropStartTime = airdropStartTime;\\n        uint256 _airdropLastTime = _airdropStartTime + airdropPeriod;\\n        if (_airdropLastTime > startTime) revert InvalidParam();\\n\\n        // pull airdrop Amount and update reserve amount\\n        if (airdrop0 > 0) {\\n            IERC20(token0).safeTransferFrom(msg.sender, address(this), airdrop0);\\n            reserve0 += airdrop0;\\n        }\\n        if (airdrop1 > 0) {\\n            IERC20(token1).safeTransferFrom(msg.sender, address(this), airdrop1);\\n            reserve1 += airdrop1;\\n        }\\n\\n        // distribute previous epoch airdrop if exist\\n        if (airdropDurationAfterLastObservation() > 0) {\\n            // update Record & distribute airdrop\\n            _updateObservationRecord(liquidity);\\n\\n            // if undistributed airdrop existed (liquidity == 0),\\n            // remained is added to the next epoch airdrop\\n            uint256 _lastObservation = lastObservation;\\n            if (_lastObservation < _airdropLastTime) {\\n                uint256 diff = _airdropLastTime - Math.max(_lastObservation, _airdropStartTime);\\n\\n                airdrop0 += SafeCast.toUint128(FullMath.mulDiv(airdrop0PerSecond, diff, FixedPoint.Q128));\\n                airdrop1 += SafeCast.toUint128(FullMath.mulDiv(airdrop1PerSecond, diff, FixedPoint.Q128));\\n            }\\n        }\\n\\n        if (airdrop0 == 0 && airdrop1 == 0) {\\n            // No airdrop in this epoch\\n            airdrop0PerSecond = 0;\\n            airdrop1PerSecond = 0;\\n            airdropStartTime = 0;\\n            airdropPeriod = 0;\\n        } else {\\n            // write airdrop Parameters\\n            airdrop0PerSecond = FullMath.mulDiv(airdrop0, FixedPoint.Q128, period);\\n            airdrop1PerSecond = FullMath.mulDiv(airdrop1, FixedPoint.Q128, period);\\n            airdropStartTime = startTime;\\n            airdropPeriod = period;\\n        }\\n    }\\n\\n    function _ensureTickSpacing(int24 lower, int24 upper) internal view {\\n        if (lower % int24(tickSpacing) != 0) revert InvalidTick();\\n        if ((lower / int24(tickSpacing)) % 2 != 0) revert LowerEven();\\n        if (upper % int24(tickSpacing) != 0) revert InvalidTick();\\n        if ((upper / int24(tickSpacing)) % 2 == 0) revert UpperOdd();\\n    }\\n\\n    function _ensureLiquidityForSwap(SwapCache memory cache) internal pure {\\n        if (cache.currentLiquidity > 0) {\\n            return;\\n        }\\n\\n        if (cache.nextTickToCross == TickMath.MIN_TICK || cache.nextTickToCross == TickMath.MAX_TICK) {\\n            // if there is no liquidity and current price is on last tick, revert transaction\\n            revert LiquidityInsufficient();\\n        }\\n    }\\n\\n    function _updateObservationRecord(uint256 currentLiquidity) internal {\\n        if (currentLiquidity == 0) return;\\n\\n        uint256 _lastObservation = uint256(lastObservation);\\n        if (block.timestamp <= _lastObservation) return;\\n\\n        _updateAirdropGrowthGlobal(currentLiquidity);\\n\\n        unchecked {\\n            // Overflow in 2106. Don't do staking rewards in the year 2106.\\n            lastObservation = uint32(block.timestamp);\\n            secondsGrowthGlobal += uint160(((block.timestamp - _lastObservation) << FixedPoint.Q128RES) / currentLiquidity);\\n        }\\n    }\\n\\n    function _updateAirdropGrowthGlobal(uint256 currentLiquidity) internal {\\n        (uint256 remain0, uint256 remain1) = airdropGrowthRemain(currentLiquidity);\\n        if (remain0 > 0) airdropGrowthGlobal0 += remain0;\\n        if (remain1 > 0) airdropGrowthGlobal1 += remain1;\\n    }\\n\\n    function airdropGrowthRemain(uint256 _liquidity) internal view returns (uint256 remain0, uint256 remain1) {\\n        if (_liquidity == 0) return (0, 0);\\n\\n        uint256 duration = airdropDurationAfterLastObservation();\\n        if (duration > 0) {\\n            unchecked {\\n                remain0 = FullMath.mulDiv(airdrop0PerSecond, duration, _liquidity);\\n                remain1 = FullMath.mulDiv(airdrop1PerSecond, duration, _liquidity);\\n            }\\n        } else {\\n            remain0 = 0;\\n            remain1 = 0;\\n        }\\n    }\\n\\n    function _updateReserves(\\n        bool zeroForOne,\\n        uint128 inAmount,\\n        uint256 amountOut\\n    ) internal {\\n        if (zeroForOne) {\\n            uint256 balance0 = _balance(token0);\\n            uint128 newBalance = reserve0 + inAmount;\\n            if (uint256(newBalance) > balance0) revert Token0Missing();\\n            reserve0 = newBalance;\\n            unchecked {\\n                reserve1 -= uint128(amountOut);\\n            }\\n        } else {\\n            uint256 balance1 = _balance(token1);\\n            uint128 newBalance = reserve1 + inAmount;\\n            if (uint256(newBalance) > balance1) revert Token1Missing();\\n            reserve1 = newBalance;\\n            unchecked {\\n                reserve0 -= uint128(amountOut);\\n            }\\n        }\\n    }\\n\\n    function _updateSwapFees(\\n        bool zeroForOne,\\n        uint256 swapFeeGrowthGlobal,\\n        uint128 _protocolFee\\n    ) internal {\\n        if (zeroForOne) {\\n            swapFeeGrowthGlobal1 = swapFeeGrowthGlobal;\\n            token1ProtocolFee += _protocolFee;\\n        } else {\\n            swapFeeGrowthGlobal0 = swapFeeGrowthGlobal;\\n            token0ProtocolFee += _protocolFee;\\n        }\\n    }\\n\\n    function _updatePosition(\\n        address owner,\\n        int24 lower,\\n        int24 upper,\\n        int128 amount\\n    ) internal {\\n        Position storage position = positions[owner][lower][upper];\\n        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(lower, upper);\\n\\n        uint256 amount0Fees;\\n        uint256 amount1Fees;\\n        unchecked {\\n            // @dev underflow is intended.\\n            amount0Fees = FullMath.mulDiv(rangeFeeGrowth0 - position.feeGrowthInside0Last, position.liquidity, FixedPoint.Q128);\\n            amount1Fees = FullMath.mulDiv(rangeFeeGrowth1 - position.feeGrowthInside1Last, position.liquidity, FixedPoint.Q128);\\n        }\\n\\n        if (amount < 0) {\\n            position.liquidity -= uint128(-amount);\\n        }\\n\\n        if (amount > 0) {\\n            position.liquidity += uint128(amount);\\n            // Prevents a global liquidity overflow in even if all ticks are initialised.\\n            if (position.liquidity > MAX_TICK_LIQUIDITY) revert LiquidityOverflow();\\n        }\\n\\n        position.feeGrowthInside0Last = rangeFeeGrowth0;\\n        position.feeGrowthInside1Last = rangeFeeGrowth1;\\n        position.feeOwed0 += uint128(amount0Fees);\\n        position.feeOwed1 += uint128(amount1Fees);\\n    }\\n\\n    function _collectFromFeeOwed(\\n        address owner,\\n        int24 lower,\\n        int24 upper,\\n        uint256 desiredToken0Fees,\\n        uint256 desiredToken1Fees\\n    ) internal returns (uint256 token0Amount, uint256 token1Amount) {\\n        Position storage position = positions[owner][lower][upper];\\n        {\\n            uint128 feeOwed0 = position.feeOwed0;\\n            uint128 token0Fees_ = desiredToken0Fees >= type(uint128).max ? feeOwed0 : uint128(desiredToken0Fees);\\n            token0Amount = token0Fees_ >= feeOwed0 ? feeOwed0 : token0Fees_;\\n        }\\n\\n        {\\n            uint128 feeOwed1 = position.feeOwed1;\\n            uint128 token1Fees_ = desiredToken1Fees >= type(uint128).max ? feeOwed1 : uint128(desiredToken1Fees);\\n            token1Amount = token1Fees_ >= feeOwed1 ? feeOwed1 : token1Fees_;\\n        }\\n\\n        position.feeOwed0 -= uint128(token0Amount);\\n        position.feeOwed1 -= uint128(token1Amount);\\n    }\\n\\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check\\n    function _balance(address token) internal view returns (uint256 balance) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\\n        require(success && data.length >= 32);\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    function _transfer(\\n        address token,\\n        uint256 shares,\\n        address to\\n    ) internal {\\n        IERC20(token).safeTransfer(to, shares);\\n    }\\n\\n    function _transferBothTokens(\\n        address to,\\n        uint256 shares0,\\n        uint256 shares1\\n    ) internal {\\n        _transfer(token0, shares0, to);\\n        _transfer(token1, shares1, to);\\n    }\\n\\n    /// @dev Generic formula for fee growth inside a range: (globalGrowth - growthBelow - growthAbove)\\n    /// - available counters: global, outside u, outside v.\\n\\n    ///                  u         \\u25bc         v\\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - feeGrowthOutside(v))\\n\\n    ///             \\u25bc    u                   v\\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - (global - feeGrowthOutside(u)) - feeGrowthOutside(v))\\n\\n    ///                  u                   v    \\u25bc\\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - (global - feeGrowthOutside(v)))\\n\\n    /// @notice Calculates the total fee growth inside a range (per unit of liquidity).\\n    /// @dev Multiply `rangeFeeGrowth` delta by the provided liquidity to get accrued fees for some period.\\n    /// @dev if lowerTick or upperTick isn't initialized, rangeFeeGrowth is calculated incorrectly\\n    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {\\n        int24 currentTick = TickMath.getTickAtSqrtRatio(price);\\n\\n        Tick memory lower = ticks[lowerTick];\\n        Tick memory upper = ticks[upperTick];\\n\\n        // Calculate fee growth below & above.\\n        uint256 _feeGrowthGlobal0;\\n        uint256 _feeGrowthGlobal1;\\n        {\\n            (uint256 remain0, uint256 remain1) = airdropGrowthRemain(liquidity);\\n            _feeGrowthGlobal0 = swapFeeGrowthGlobal0 + airdropGrowthGlobal0 + remain0;\\n            _feeGrowthGlobal1 = swapFeeGrowthGlobal1 + airdropGrowthGlobal1 + remain1;\\n        }\\n\\n        uint256 feeGrowthBelow0;\\n        uint256 feeGrowthBelow1;\\n        uint256 feeGrowthAbove0;\\n        uint256 feeGrowthAbove1;\\n        if (lowerTick <= currentTick) {\\n            feeGrowthBelow0 = lower.feeGrowthOutside0;\\n            feeGrowthBelow1 = lower.feeGrowthOutside1;\\n        } else {\\n            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;\\n            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;\\n        }\\n\\n        if (currentTick < upperTick) {\\n            feeGrowthAbove0 = upper.feeGrowthOutside0;\\n            feeGrowthAbove1 = upper.feeGrowthOutside1;\\n        } else {\\n            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;\\n            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;\\n        }\\n\\n        unchecked {\\n            // @dev underflow is intended\\n            // reference : https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13\\n            feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;\\n            feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;\\n        }\\n    }\\n\\n    function getAssets() external view returns (address[] memory assets) {\\n        assets = new address[](2);\\n        assets[0] = token0;\\n        assets[1] = token1;\\n    }\\n\\n    function getImmutables()\\n        external\\n        view\\n        returns (\\n            uint128 _MAX_TICK_LIQUIDITY,\\n            uint24 _tickSpacing,\\n            uint24 _swapFee,\\n            address _factory,\\n            address _masterDeployer,\\n            address _token0,\\n            address _token1\\n        )\\n    {\\n        _MAX_TICK_LIQUIDITY = MAX_TICK_LIQUIDITY;\\n        _tickSpacing = tickSpacing;\\n        _swapFee = swapFee;\\n        _factory = factory;\\n        _masterDeployer = address(masterDeployer);\\n        _token0 = token0;\\n        _token1 = token1;\\n    }\\n\\n    /// @notice The total fee growth of token0 collected per unit of liquidity for the entire life of the pool\\n    function feeGrowthGlobal0() external view returns (uint256) {\\n        return _feeGrowthGlobal(swapFeeGrowthGlobal0, airdropGrowthGlobal0, airdrop0PerSecond);\\n    }\\n\\n    /// @notice The total fee growth of token1 collected per unit of liquidity for the entire life of the pool\\n    function feeGrowthGlobal1() external view returns (uint256) {\\n        return _feeGrowthGlobal(swapFeeGrowthGlobal1, airdropGrowthGlobal1, airdrop1PerSecond);\\n    }\\n\\n    function _feeGrowthGlobal(\\n        uint256 _swapFeeGrowthGlobal,\\n        uint256 _airdropGrowthGlobal,\\n        uint256 _airdropPerSecond\\n    ) internal view returns (uint256) {\\n        uint256 duration = airdropDurationAfterLastObservation();\\n        uint256 _liquidity = liquidity;\\n        if (duration > 0 && _liquidity > 0) {\\n            return _swapFeeGrowthGlobal + _airdropGrowthGlobal + FullMath.mulDiv(_airdropPerSecond, duration, _liquidity);\\n        } else {\\n            return _swapFeeGrowthGlobal + _airdropGrowthGlobal;\\n        }\\n    }\\n\\n    function airdropDurationAfterLastObservation() internal view returns (uint256) {\\n        uint256 _airdropStartTime = airdropStartTime;\\n        if (_airdropStartTime >= block.timestamp) {\\n            // airdrop is not started\\n            return 0;\\n        }\\n\\n        uint256 _lastObservation = lastObservation;\\n        uint256 _airdropEndTime = _airdropStartTime + airdropPeriod;\\n        if (_airdropEndTime <= _lastObservation) {\\n            // airdrop is ended\\n            return 0;\\n        }\\n\\n        return Math.min(block.timestamp, _airdropEndTime) - Math.max(_lastObservation, _airdropStartTime);\\n    }\\n\\n    function getPriceAndNearestTicks() external view returns (uint160 _price, int24 _nearestTick) {\\n        _price = price;\\n        _nearestTick = nearestTick;\\n    }\\n\\n    function getTokenProtocolFees() external view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee) {\\n        _token0ProtocolFee = token0ProtocolFee;\\n        _token1ProtocolFee = token1ProtocolFee;\\n    }\\n\\n    function getReserves() external view returns (uint128 _reserve0, uint128 _reserve1) {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n    }\\n\\n    function getSecondsGrowthAndLastObservation() external view returns (uint160 _secondsGrowthGlobal, uint32 _lastObservation) {\\n        _secondsGrowthGlobal = secondsGrowthGlobal;\\n        _lastObservation = lastObservation;\\n    }\\n}\\n\",\"keccak256\":\"0xcb969e313985dc65d422aa150c32e5159bfd5b6e9eeba1ea5c417a245a05bf13\",\"license\":\"GPL-3.0\"},\"contracts/pool/ConcentratedLiquidityPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n *\\n * #####    ##   #    #  ####  ######   ##      #####  #####   ####  #####  ####   ####   ####  #\\n * #    #  #  #  ##   # #    # #       #  #     #    # #    # #    #   #   #    # #    # #    # #\\n * #    # #    # # #  # #      #####  #    #    #    # #    # #    #   #   #    # #      #    # #\\n * #####  ###### #  # # #  ### #      ######    #####  #####  #    #   #   #    # #      #    # #\\n * #      #    # #   ## #    # #      #    #    #      #   #  #    #   #   #    # #    # #    # #\\n * #      #    # #    #  ####  ###### #    #    #      #    #  ####    #    ####   ####   ####  ######\\n *\\n */\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../interfaces/IPoolFactoryCallee.sol\\\";\\nimport \\\"../interfaces/IConcentratedLiquidityPoolFactory.sol\\\";\\nimport \\\"./ConcentratedLiquidityPool.sol\\\";\\nimport \\\"./PoolFactoryLib.sol\\\";\\n\\n/// @notice Contract for deploying Concentrated Liquidity Pool\\ncontract ConcentratedLiquidityPoolFactory is OwnableUpgradeable, IConcentratedLiquidityPoolFactory {\\n    address public masterDeployer;\\n    address public poolLogger;\\n\\n    mapping(address => mapping(address => address[])) public pools;\\n    mapping(bytes32 => address) public configAddress;\\n    mapping(address => bool) public isPool;\\n    mapping(uint24 => mapping(uint24 => bool)) public availableFeeAndTickSpacing;\\n\\n    address[] private poolArray;\\n\\n    error WrongTokenOrder();\\n    error UnauthorisedDeployer();\\n    error ZeroAddress();\\n    error InvalidFeeAndTickSpacing();\\n\\n    function initialize(address _masterDeployer, address _poolLogger) external initializer {\\n        if (_masterDeployer == address(0)) revert ZeroAddress();\\n        if (_poolLogger == address(0)) revert ZeroAddress();\\n        masterDeployer = _masterDeployer;\\n        poolLogger = _poolLogger;\\n\\n        availableFeeAndTickSpacing[10_000][100] = true; // swapFee = 1.0%  / tickSpacing = 100\\n        availableFeeAndTickSpacing[2_000][20] = true; // swapFee = 0.2%  / tickSpacing =  20\\n        availableFeeAndTickSpacing[600][6] = true; // swapFee = 0.06% / tickSpacing =   6\\n        availableFeeAndTickSpacing[100][1] = true; // swapFee = 0.01% / tickSpacing =   1\\n\\n        __Ownable_init();\\n    }\\n\\n    function setAvailableFeeAndTickSpacing(\\n        uint24 fee,\\n        uint24 tickSpacing,\\n        bool ok\\n    ) external onlyOwner {\\n        availableFeeAndTickSpacing[fee][tickSpacing] = ok;\\n    }\\n\\n    function deployPool(bytes memory _deployData) external returns (address pool) {\\n        if (msg.sender != masterDeployer) revert UnauthorisedDeployer();\\n\\n        (address tokenA, address tokenB, uint24 swapFee, uint160 price, uint24 tickSpacing) = abi.decode(\\n            _deployData,\\n            (address, address, uint24, uint160, uint24)\\n        );\\n\\n        // Revert instead of switching tokens and inverting price.\\n        if (tokenA > tokenB) revert WrongTokenOrder();\\n        if (!availableFeeAndTickSpacing[swapFee][tickSpacing]) revert InvalidFeeAndTickSpacing();\\n\\n        // Strips any extra data.\\n        // Don't include price in _deployData to enable predictable address calculation.\\n        _deployData = abi.encode(tokenA, tokenB, swapFee, tickSpacing);\\n        bytes32 salt = keccak256(_deployData);\\n        pool = PoolFactoryLib.createPool(_deployData, masterDeployer);\\n\\n        configAddress[salt] = pool;\\n        pools[tokenA][tokenB].push(pool);\\n        pools[tokenB][tokenA].push(pool);\\n        isPool[pool] = true;\\n        poolArray.push(pool);\\n\\n        IPoolFactoryCallee(pool).setPrice(price);\\n        IPoolFactoryCallee(pool).registerLogger(poolLogger);\\n    }\\n\\n    function totalPoolsCount() external view returns (uint256 total) {\\n        return poolArray.length;\\n    }\\n\\n    function getPoolAddress(uint256 idx) external view returns (address pool) {\\n        return poolArray[idx];\\n    }\\n\\n    function poolsCount(address token0, address token1) external view returns (uint256 count) {\\n        count = pools[token0][token1].length;\\n    }\\n\\n    function getPools(\\n        address token0,\\n        address token1,\\n        uint256 startIndex,\\n        uint256 count\\n    ) external view returns (address[] memory pairPools) {\\n        pairPools = new address[](count);\\n        for (uint256 i = 0; i < count; i++) {\\n            pairPools[i] = pools[token0][token1][startIndex + i];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc47a4630cdedbc61cd330c34990b9c6d62a45c04c473f3213173434607d0c7eb\",\"license\":\"GPL-3.0\"},\"contracts/pool/PoolFactoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n *\\n * #####    ##   #    #  ####  ######   ##      #####  #####   ####  #####  ####   ####   ####  #\\n * #    #  #  #  ##   # #    # #       #  #     #    # #    # #    #   #   #    # #    # #    # #\\n * #    # #    # # #  # #      #####  #    #    #    # #    # #    #   #   #    # #      #    # #\\n * #####  ###### #  # # #  ### #      ######    #####  #####  #    #   #   #    # #      #    # #\\n * #      #    # #   ## #    # #      #    #    #      #   #  #    #   #   #    # #    # #    # #\\n * #      #    # #    #  ####  ###### #    #    #      #    #  ####    #    ####   ####   ####  ######\\n *\\n */\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ConcentratedLiquidityPool.sol\\\";\\nimport \\\"../interfaces/IMasterDeployer.sol\\\";\\n\\nlibrary PoolFactoryLib {\\n    function createPool(bytes memory _deployData, address masterDeployer) external returns (address) {\\n        // Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\\n        bytes32 salt = keccak256(_deployData);\\n        return address(new ConcentratedLiquidityPool{salt: salt}(_deployData, IMasterDeployer(masterDeployer)));\\n    }\\n}\\n\",\"keccak256\":\"0x570e5f3f7ef2c7b5c7350e89c14bc49fed76cbddfad40a7269ee452dee581c0a\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506115a9806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ff5760003560e01c80635bc93d6c116100975780639ee6465b116100665780639ee6465b14610280578063cf58879a146102ae578063f2fde38b146102ce578063f6ab6d99146102e157600080fd5b80635bc93d6c146101f4578063715018a61461023a57806371a25812146102425780638da5cb5b1461026257600080fd5b80635159d73c116100d35780635159d73c1461017c57806356088ff11461018f578063566a89af146101af5780635b16ebb7146101c157600080fd5b8062a5ae2114610104578063169c4cef1461014157806327c3cae114610154578063485cc95514610167575b600080fd5b61011761011236600461109b565b610317565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61011761014f3660046110d6565b610354565b610117610162366004611146565b6103a6565b61017a610175366004611215565b610829565b005b61017a61018a36600461125f565b610b38565b6066546101179073ffffffffffffffffffffffffffffffffffffffff1681565b606b545b604051908152602001610138565b6101e46101cf3660046112af565b60696020526000908152604090205460ff1681565b6040519015158152602001610138565b6101b3610202366004611215565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260676020908152604080832093909416825291909152205490565b61017a610c0d565b6102556102503660046112d3565b610c9a565b6040516101389190611319565b60335473ffffffffffffffffffffffffffffffffffffffff16610117565b6101e461028e366004611373565b606a60209081526000928352604080842090915290825290205460ff1681565b6065546101179073ffffffffffffffffffffffffffffffffffffffff1681565b61017a6102dc3660046112af565b610db5565b6101176102ef36600461109b565b60686020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff1681565b6000606b828154811061032c5761032c6113a1565b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff1692915050565b6067602052826000526040600020602052816000526040600020818154811061037c57600080fd5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16925083915050565b60655460009073ffffffffffffffffffffffffffffffffffffffff1633146103fa576040517f03781a5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008060008060008680602001905181019061041691906113d0565b945094509450945094508373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161115610486576040517f30082a1600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b62ffffff8084166000908152606a602090815260408083209385168352929052205460ff166104e1576040517fb87686b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040805173ffffffffffffffffffffffffffffffffffffffff808816602083015286169181019190915262ffffff80851660608301528216608082015260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052805160208201206065547fb3fa34ae00000000000000000000000000000000000000000000000000000000845291995091737Ee422bb110C136578ef34842f2213fa5Ae5f9a89163b3fa34ae916105c4918c9173ffffffffffffffffffffffffffffffffffffffff90911690600401611445565b60206040518083038186803b1580156105dc57600080fd5b505af41580156105f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061491906114d6565b6000828152606860209081526040808320805473ffffffffffffffffffffffffffffffffffffffff8681167fffffffffffffffffffffffff000000000000000000000000000000000000000092831681179093558c811680875260678087528588208e8416808a52908852868920805460018181018355918b52898b2001805487168817905590895290875285882091885290865284872080548083018255908852868820018054841685179055838752606990955283862080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686179055606b805495860181559095527fbd43cb8ece8cd1863bcd6082d65c5b0d25665b1ce17980f0da43c0ed545f98b490930180549093168117909255517fd90bda4e000000000000000000000000000000000000000000000000000000008152918616600483015291985063d90bda4e90602401600060405180830381600087803b15801561078157600080fd5b505af1158015610795573d6000803e3d6000fd5b50506066546040517fbd7d1eea00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9182166004820152908a16925063bd7d1eea9150602401600060405180830381600087803b15801561080657600080fd5b505af115801561081a573d6000803e3d6000fd5b50505050505050505050919050565b600054610100900460ff166108445760005460ff1615610848565b303b155b6108d9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084015b60405180910390fd5b600054610100900460ff1615801561091857600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000166101011790555b73ffffffffffffffffffffffffffffffffffffffff8316610965576040517fd92e233d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff82166109b2576040517fd92e233d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6065805473ffffffffffffffffffffffffffffffffffffffff8086167fffffffffffffffffffffffff00000000000000000000000000000000000000009283161790925560668054928516929091169190911790557fc714f2dd66168dd73a29e986fb55ced94ca972bc1b50fba080a30cd2181ee46180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0090811660019081179092557f2b883f690d77611dc5b41697da3a6d594aa0f341ca97ec610373f8acb41cd82e80548216831790557fb4c39d8f35323a7236928a191047e8e590183539305f30f3125ad48275693c6f805482168317905560008290527fcd6a478cde0daf30ff37adc42daba04d5778c598dbf4183faa56b8a367a7a2fa6020527f4b36f0357877a40c82357bd8a2a008c963de23de2cbbc2a838194b639b2b4da180549091169091179055610b04610ee5565b8015610b3357600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff1690555b505050565b60335473ffffffffffffffffffffffffffffffffffffffff163314610bb9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b62ffffff9283166000908152606a602090815260408083209490951682529290925291902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60335473ffffffffffffffffffffffffffffffffffffffff163314610c8e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b610c986000610f84565b565b60608167ffffffffffffffff811115610cb557610cb5611117565b604051908082528060200260200182016040528015610cde578160200160208202803683370190505b50905060005b82811015610dac5773ffffffffffffffffffffffffffffffffffffffff8087166000908152606760209081526040808320938916835292905220610d288286611522565b81548110610d3857610d386113a1565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16828281518110610d7557610d756113a1565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015280610da48161153a565b915050610ce4565b50949350505050565b60335473ffffffffffffffffffffffffffffffffffffffff163314610e36576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b73ffffffffffffffffffffffffffffffffffffffff8116610ed9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108d0565b610ee281610f84565b50565b600054610100900460ff16610f7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108d0565b610c98610ffb565b6033805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff16611092576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108d0565b610c9833610f84565b6000602082840312156110ad57600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610ee257600080fd5b6000806000606084860312156110eb57600080fd5b83356110f6816110b4565b92506020840135611106816110b4565b929592945050506040919091013590565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006020828403121561115857600080fd5b813567ffffffffffffffff8082111561117057600080fd5b818401915084601f83011261118457600080fd5b81358181111561119657611196611117565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156111dc576111dc611117565b816040528281528760208487010111156111f557600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000806040838503121561122857600080fd5b8235611233816110b4565b91506020830135611243816110b4565b809150509250929050565b62ffffff81168114610ee257600080fd5b60008060006060848603121561127457600080fd5b833561127f8161124e565b9250602084013561128f8161124e565b9150604084013580151581146112a457600080fd5b809150509250925092565b6000602082840312156112c157600080fd5b81356112cc816110b4565b9392505050565b600080600080608085870312156112e957600080fd5b84356112f4816110b4565b93506020850135611304816110b4565b93969395505050506040820135916060013590565b6020808252825182820181905260009190848201906040850190845b8181101561136757835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101611335565b50909695505050505050565b6000806040838503121561138657600080fd5b82356113918161124e565b915060208301356112438161124e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080600080600060a086880312156113e857600080fd5b85516113f3816110b4565b6020870151909550611404816110b4565b60408701519094506114158161124e565b6060870151909350611426816110b4565b60808701519092506114378161124e565b809150509295509295909350565b604081526000835180604084015260005b818110156114735760208187018101516060868401015201611456565b81811115611485576000606083860101525b5073ffffffffffffffffffffffffffffffffffffffff93909316602083015250601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601606001919050565b6000602082840312156114e857600080fd5b81516112cc816110b4565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115611535576115356114f3565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561156c5761156c6114f3565b506001019056fea2646970667358221220501655aba72504ec3fe4070183e3a038ec1797a3b419316a6338ed333e18200964736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ff5760003560e01c80635bc93d6c116100975780639ee6465b116100665780639ee6465b14610280578063cf58879a146102ae578063f2fde38b146102ce578063f6ab6d99146102e157600080fd5b80635bc93d6c146101f4578063715018a61461023a57806371a25812146102425780638da5cb5b1461026257600080fd5b80635159d73c116100d35780635159d73c1461017c57806356088ff11461018f578063566a89af146101af5780635b16ebb7146101c157600080fd5b8062a5ae2114610104578063169c4cef1461014157806327c3cae114610154578063485cc95514610167575b600080fd5b61011761011236600461109b565b610317565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61011761014f3660046110d6565b610354565b610117610162366004611146565b6103a6565b61017a610175366004611215565b610829565b005b61017a61018a36600461125f565b610b38565b6066546101179073ffffffffffffffffffffffffffffffffffffffff1681565b606b545b604051908152602001610138565b6101e46101cf3660046112af565b60696020526000908152604090205460ff1681565b6040519015158152602001610138565b6101b3610202366004611215565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260676020908152604080832093909416825291909152205490565b61017a610c0d565b6102556102503660046112d3565b610c9a565b6040516101389190611319565b60335473ffffffffffffffffffffffffffffffffffffffff16610117565b6101e461028e366004611373565b606a60209081526000928352604080842090915290825290205460ff1681565b6065546101179073ffffffffffffffffffffffffffffffffffffffff1681565b61017a6102dc3660046112af565b610db5565b6101176102ef36600461109b565b60686020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff1681565b6000606b828154811061032c5761032c6113a1565b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff1692915050565b6067602052826000526040600020602052816000526040600020818154811061037c57600080fd5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16925083915050565b60655460009073ffffffffffffffffffffffffffffffffffffffff1633146103fa576040517f03781a5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008060008060008680602001905181019061041691906113d0565b945094509450945094508373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161115610486576040517f30082a1600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b62ffffff8084166000908152606a602090815260408083209385168352929052205460ff166104e1576040517fb87686b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040805173ffffffffffffffffffffffffffffffffffffffff808816602083015286169181019190915262ffffff80851660608301528216608082015260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052805160208201206065547fb3fa34ae0000000000000000000000000000000000000000000000000000000084529199509173__$65be32de914435d9328d178fb214e9d46f$__9163b3fa34ae916105c4918c9173ffffffffffffffffffffffffffffffffffffffff90911690600401611445565b60206040518083038186803b1580156105dc57600080fd5b505af41580156105f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061491906114d6565b6000828152606860209081526040808320805473ffffffffffffffffffffffffffffffffffffffff8681167fffffffffffffffffffffffff000000000000000000000000000000000000000092831681179093558c811680875260678087528588208e8416808a52908852868920805460018181018355918b52898b2001805487168817905590895290875285882091885290865284872080548083018255908852868820018054841685179055838752606990955283862080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686179055606b805495860181559095527fbd43cb8ece8cd1863bcd6082d65c5b0d25665b1ce17980f0da43c0ed545f98b490930180549093168117909255517fd90bda4e000000000000000000000000000000000000000000000000000000008152918616600483015291985063d90bda4e90602401600060405180830381600087803b15801561078157600080fd5b505af1158015610795573d6000803e3d6000fd5b50506066546040517fbd7d1eea00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9182166004820152908a16925063bd7d1eea9150602401600060405180830381600087803b15801561080657600080fd5b505af115801561081a573d6000803e3d6000fd5b50505050505050505050919050565b600054610100900460ff166108445760005460ff1615610848565b303b155b6108d9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084015b60405180910390fd5b600054610100900460ff1615801561091857600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000166101011790555b73ffffffffffffffffffffffffffffffffffffffff8316610965576040517fd92e233d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff82166109b2576040517fd92e233d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6065805473ffffffffffffffffffffffffffffffffffffffff8086167fffffffffffffffffffffffff00000000000000000000000000000000000000009283161790925560668054928516929091169190911790557fc714f2dd66168dd73a29e986fb55ced94ca972bc1b50fba080a30cd2181ee46180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0090811660019081179092557f2b883f690d77611dc5b41697da3a6d594aa0f341ca97ec610373f8acb41cd82e80548216831790557fb4c39d8f35323a7236928a191047e8e590183539305f30f3125ad48275693c6f805482168317905560008290527fcd6a478cde0daf30ff37adc42daba04d5778c598dbf4183faa56b8a367a7a2fa6020527f4b36f0357877a40c82357bd8a2a008c963de23de2cbbc2a838194b639b2b4da180549091169091179055610b04610ee5565b8015610b3357600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff1690555b505050565b60335473ffffffffffffffffffffffffffffffffffffffff163314610bb9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b62ffffff9283166000908152606a602090815260408083209490951682529290925291902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60335473ffffffffffffffffffffffffffffffffffffffff163314610c8e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b610c986000610f84565b565b60608167ffffffffffffffff811115610cb557610cb5611117565b604051908082528060200260200182016040528015610cde578160200160208202803683370190505b50905060005b82811015610dac5773ffffffffffffffffffffffffffffffffffffffff8087166000908152606760209081526040808320938916835292905220610d288286611522565b81548110610d3857610d386113a1565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16828281518110610d7557610d756113a1565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015280610da48161153a565b915050610ce4565b50949350505050565b60335473ffffffffffffffffffffffffffffffffffffffff163314610e36576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108d0565b73ffffffffffffffffffffffffffffffffffffffff8116610ed9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108d0565b610ee281610f84565b50565b600054610100900460ff16610f7c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108d0565b610c98610ffb565b6033805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff16611092576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108d0565b610c9833610f84565b6000602082840312156110ad57600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114610ee257600080fd5b6000806000606084860312156110eb57600080fd5b83356110f6816110b4565b92506020840135611106816110b4565b929592945050506040919091013590565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006020828403121561115857600080fd5b813567ffffffffffffffff8082111561117057600080fd5b818401915084601f83011261118457600080fd5b81358181111561119657611196611117565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156111dc576111dc611117565b816040528281528760208487010111156111f557600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000806040838503121561122857600080fd5b8235611233816110b4565b91506020830135611243816110b4565b809150509250929050565b62ffffff81168114610ee257600080fd5b60008060006060848603121561127457600080fd5b833561127f8161124e565b9250602084013561128f8161124e565b9150604084013580151581146112a457600080fd5b809150509250925092565b6000602082840312156112c157600080fd5b81356112cc816110b4565b9392505050565b600080600080608085870312156112e957600080fd5b84356112f4816110b4565b93506020850135611304816110b4565b93969395505050506040820135916060013590565b6020808252825182820181905260009190848201906040850190845b8181101561136757835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101611335565b50909695505050505050565b6000806040838503121561138657600080fd5b82356113918161124e565b915060208301356112438161124e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080600080600060a086880312156113e857600080fd5b85516113f3816110b4565b6020870151909550611404816110b4565b60408701519094506114158161124e565b6060870151909350611426816110b4565b60808701519092506114378161124e565b809150509295509295909350565b604081526000835180604084015260005b818110156114735760208187018101516060868401015201611456565b81811115611485576000606083860101525b5073ffffffffffffffffffffffffffffffffffffffff93909316602083015250601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601606001919050565b6000602082840312156114e857600080fd5b81516112cc816110b4565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115611535576115356114f3565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561156c5761156c6114f3565b506001019056fea2646970667358221220501655aba72504ec3fe4070183e3a038ec1797a3b419316a6338ed333e18200964736f6c63430008090033",
  "libraries": {
    "PoolFactoryLib": "0x7Ee422bb110C136578ef34842f2213fa5Ae5f9a8"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "stateVariables": {
      "configAddress": {
        "params": {
          "data": "abi.encode(address tokenA, address tokenB, uint24 swapFee, uint24 tickSpacing);"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "configAddress(bytes32)": {
        "notice": "Return the address of the pool created with the given config data"
      },
      "getPoolAddress(uint256)": {
        "notice": "Return the address of pool by index"
      },
      "getPools(address,address,uint256,uint256)": {
        "notice": "Return the list of pools composed of two tokens"
      },
      "isPool(address)": {
        "notice": "Return whether the pool is created by the factory"
      },
      "poolsCount(address,address)": {
        "notice": "Return the number of pools composed of two tokens"
      },
      "totalPoolsCount()": {
        "notice": "Return the number of pools deployed from factory"
      }
    },
    "notice": "Contract for deploying Concentrated Liquidity Pool",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 130,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 133,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1981,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 10,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 122,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 15534,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "masterDeployer",
        "offset": 0,
        "slot": "101",
        "type": "t_address"
      },
      {
        "astId": 15536,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "poolLogger",
        "offset": 0,
        "slot": "102",
        "type": "t_address"
      },
      {
        "astId": 15543,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "pools",
        "offset": 0,
        "slot": "103",
        "type": "t_mapping(t_address,t_mapping(t_address,t_array(t_address)dyn_storage))"
      },
      {
        "astId": 15547,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "configAddress",
        "offset": 0,
        "slot": "104",
        "type": "t_mapping(t_bytes32,t_address)"
      },
      {
        "astId": 15551,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "isPool",
        "offset": 0,
        "slot": "105",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 15557,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "availableFeeAndTickSpacing",
        "offset": 0,
        "slot": "106",
        "type": "t_mapping(t_uint24,t_mapping(t_uint24,t_bool))"
      },
      {
        "astId": 15560,
        "contract": "contracts/pool/ConcentratedLiquidityPoolFactory.sol:ConcentratedLiquidityPoolFactory",
        "label": "poolArray",
        "offset": 0,
        "slot": "107",
        "type": "t_array(t_address)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_array(t_address)dyn_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => address[]))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_array(t_address)dyn_storage)"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint24,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint24",
        "label": "mapping(uint24 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint24,t_mapping(t_uint24,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint24",
        "label": "mapping(uint24 => mapping(uint24 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint24,t_bool)"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}